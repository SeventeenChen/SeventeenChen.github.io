<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Seventeen</title>
  
  <subtitle>All is well</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-11T06:13:51.135Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Seventeen Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spectrogram</title>
    <link href="http://yoursite.com/2020/05/10/spectrogram/"/>
    <id>http://yoursite.com/2020/05/10/spectrogram/</id>
    <published>2020-05-10T14:34:03.000Z</published>
    <updated>2020-05-11T06:13:51.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="S3-Spectrogram-Table"><a href="#S3-Spectrogram-Table" class="headerlink" title="S3 Spectrogram Table "></a><center>S3 Spectrogram Table</center></h1><table><thead><tr><th align="center"><img src="https://wx2.sbimg.cn/2020/05/11/D7_803_clean.jpg" alt="D7_803_clean.jpg"></th></tr></thead><tbody><tr><td align="center"><div id="aplayer-tcQxHhtH" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-tcQxHhtH"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"clean",author:"szu",url:"D7_803_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><img src="https://wx1.sbimg.cn/2020/05/11/D7_803_nb.jpg" alt="D7_803_nb.jpg"></td></tr><tr><td align="center"><div id="aplayer-tfIDbmEc" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-tfIDbmEc"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"narrow band",author:"szu",url:"D7_803_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><img src="https://wx2.sbimg.cn/2020/05/11/D7_803_cnnNb_entropyloss.jpg" alt="D7_803_cnnNb_entropyloss.jpg"></td></tr><tr><td align="center"><div id="aplayer-fHMsqpPx" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap = new APlayer({            element: document.getElementById("aplayer-fHMsqpPx"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "entropy loss",              author: "szu"",              url: "D7_803_cnnNb_entropyloss.wav",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);</script></td></tr><tr><td align="center"><img src="https://wx2.sbimg.cn/2020/05/11/D7_803_cnnNb_mpegloss.jpg" alt="D7_803_cnnNb_mpegloss.jpg"></td></tr><tr><td align="center"><div id="aplayer-TJqHCeYw" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap = new APlayer({            element: document.getElementById("aplayer-TJqHCeYw"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "mpeg loss",              author: "szu"",              url: "D7_803_cnnNb_mpegloss.wav",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);</script></td></tr><tr><td align="center"><img src="https://wx2.sbimg.cn/2020/05/11/D7_803_cnnNb_mseloss.jpg" alt="D7_803_cnnNb_mseloss.jpg"></td></tr><tr><td align="center"><div id="aplayer-xSEYGekn" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap = new APlayer({            element: document.getElementById("aplayer-xSEYGekn"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "mse loss",              author: "szu"",              url: "D7_803_cnnNb_mseloss.wav",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);</script></td></tr><tr><td align="center"><img src="https://wx2.sbimg.cn/2020/05/11/D7_803_cnnNb_perceptualloss.jpg" alt="D7_803_cnnNb_perceptualloss.jpg"></td></tr><tr><td align="center"><div id="aplayer-ulShbYEL" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-ulShbYEL"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"perceptual loss",author:"szu",url:"D7_803_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="spectrogram" scheme="http://yoursite.com/tags/spectrogram/"/>
    
  </entry>
  
  <entry>
    <title>Listening Test</title>
    <link href="http://yoursite.com/2020/04/28/Listening-Test/"/>
    <id>http://yoursite.com/2020/04/28/Listening-Test/</id>
    <published>2020-04-28T11:45:08.000Z</published>
    <updated>2020-05-01T16:38:06.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h1><ol><li><p><strong>MOS</strong> evaluation for NN-based speech super-resolution.</p></li><li><p>Listen to all utterances in the Table and score them subjectively. In specific, the clean audio files serve as the reference, which are the ceiling perceived quality comparing to those processed by other methods, such as NB.</p></li><li><p>MOS ranges from 1 to 5. The higher score, the better performance.</p><h1 id="Mos-Table"><a href="#Mos-Table" class="headerlink" title="Mos Table"></a><center>Mos Table</center></h1><table><thead><tr><th align="center"><center>Rating</center></th><th align="center"><center>Label</center></th></tr></thead><tbody><tr><td align="center"><center>5</center></td><td align="center"><center>Excellent</center></td></tr><tr><td align="center"><center>4</center></td><td align="center"><center>Good</center></td></tr><tr><td align="center"><center>3</center></td><td align="center"><center>Fair</center></td></tr><tr><td align="center"><center>2</center></td><td align="center"><center>Poor</center></td></tr><tr><td align="center"><center>1</center></td><td align="center"><center>Bad</center></td></tr></tbody></table></li></ol><h1 id="Test-Table-1-——-Narrow-Band"><a href="#Test-Table-1-——-Narrow-Band" class="headerlink" title="Test Table 1 —— Narrow Band"></a><center>Test Table 1 —— Narrow Band</center></h1><table><thead><tr><th align="center"></th><th align="center"><center>Clean</center></th><th align="center"><center>NB</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th></tr></thead><tbody><tr><td align="center"><strong><center>S1</center></strong></td><td align="center"><div id="aplayer-IlmpGkqV" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-IlmpGkqV"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_clean",author:"Yp_S",url:"D6_763_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-SzUeulua" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-SzUeulua"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_nb",author:"Yp_S",url:"D6_763_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-QpMYcmel" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-QpMYcmel"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_cnnNb_1",author:"Yp_S",url:"D6_763_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-TzjeHmMv" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-TzjeHmMv"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_cnnNb_2",author:"Yp_S",url:"D6_763_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-AZUoHsNt" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-AZUoHsNt"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_cnnNb_3",author:"Yp_S",url:"D6_763_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-KxsuVXKY" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-KxsuVXKY"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_cnnNb_4",author:"Yp_S",url:"D6_763_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos11"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos11"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos11"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos11"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos11"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos12"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos12"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos12"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos12"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos12"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos13"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos13"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos13"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos13"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos13"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos14"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos14"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos14"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos14"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos14"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong><center>S2</center></strong></td><td align="center"><div id="aplayer-ubwxNcXF" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-ubwxNcXF"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_clean",author:"Yp_S",url:"D6_775_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-JqomRnZV" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-JqomRnZV"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_nb",author:"Yp_S",url:"D6_775_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-sPcOZgIq" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-sPcOZgIq"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_cnnNb_1",author:"Yp_S",url:"D6_775_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-PekNKMXp" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-PekNKMXp"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_cnnNb_2",author:"Yp_S",url:"D6_775_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-VSpZFHZg" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-VSpZFHZg"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_cnnNb_3",author:"Yp_S",url:"D6_775_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-fGSXBKej" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-fGSXBKej"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_cnnNb_4",author:"Yp_S",url:"D6_775_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos21"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos21"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos21"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos21"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos21"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos22"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos22"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos22"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos22"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos22"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos23"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos23"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos23"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos23"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos23"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos24"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos24"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos24"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos24"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos24"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong><center>S3</center></strong></td><td align="center"><div id="aplayer-VOEusGGe" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-VOEusGGe"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_clean",author:"Yp_S",url:"D7_803_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-TuzOShKB" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-TuzOShKB"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_nb",author:"Yp_S",url:"D7_803_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-DZoImQQo" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-DZoImQQo"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_cnnNb_1",author:"Yp_S",url:"D7_803_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-sdmLyGYw" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-sdmLyGYw"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_cnnNb_2",author:"Yp_S",url:"D7_803_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-KtoezXEB" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-KtoezXEB"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_cnnNb_3",author:"Yp_S",url:"D7_803_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-sDhZAwtY" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-sDhZAwtY"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_cnnNb_4",author:"Yp_S",url:"D7_803_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos31"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos31"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos31"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos31"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos31"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos32"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos32"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos32"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos32"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos32"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos33"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos33"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos33"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos33"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos33"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos34"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos34"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos34"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos34"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos34"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong><center>S4</center></strong></td><td align="center"><div id="aplayer-fzPzaGnh" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-fzPzaGnh"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_clean",author:"Yp_S",url:"D11_808_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-ggLTOAQU" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-ggLTOAQU"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_nb",author:"Yp_S",url:"D11_808_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-QDKwBVLa" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-QDKwBVLa"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_cnnNb_1",author:"Yp_S",url:"D11_808_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-dqxhgoQD" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-dqxhgoQD"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_cnnNb_2",author:"Yp_S",url:"D11_808_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-LnLRbgpO" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-LnLRbgpO"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_cnnNb_3",author:"Yp_S",url:"D11_808_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-vwzHpKSO" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-vwzHpKSO"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_cnnNb_4",author:"Yp_S",url:"D11_808_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos41"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos41"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos41"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos41"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos41"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos42"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos42"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos42"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos42"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos42"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos43"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos43"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos43"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos43"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos43"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos44"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos44"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos44"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos44"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos44"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong><center>S5</center></strong></td><td align="center"><div id="aplayer-ZguunNkw" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-ZguunNkw"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_clean",author:"Yp_S",url:"D12_770_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-NMTTQPDr" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-NMTTQPDr"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_nb",author:"Yp_S",url:"D12_770_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-VnYwxveU" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-VnYwxveU"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_cnnNb_1",author:"Yp_S",url:"D12_770_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-shejYBdJ" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-shejYBdJ"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_cnnNb_2",author:"Yp_S",url:"D12_770_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-eTDVtWYJ" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-eTDVtWYJ"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_cnnNb_3",author:"Yp_S",url:"D12_770_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-DJSwbGHO" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-DJSwbGHO"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_3",author:"Yp_S",url:"D12_770_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos51"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos51"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos51"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos51"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos51"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos52"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos52"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos52"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos52"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos52"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos53"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos53"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos53"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos53"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos53"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos54"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos54"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos54"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos54"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos54"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong><center>S6</center></strong></td><td align="center"><div id="aplayer-ZUoumNXP" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-ZUoumNXP"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_clean",author:"Yp_S",url:"D12_780_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-cRhzOyOe" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-cRhzOyOe"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_nb",author:"Yp_S",url:"D12_780_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-uZpRnFhN" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-uZpRnFhN"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_cnnNb_1",author:"Yp_S",url:"D12_780_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-NwMCeDMg" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-NwMCeDMg"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_cnnNb_2",author:"Yp_S",url:"D12_780_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-MkfaIbGp" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-MkfaIbGp"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_cnnNb_3",author:"Yp_S",url:"D12_780_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-qmhBOHBr" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-qmhBOHBr"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_cnnNb_4",author:"Yp_S",url:"D12_780_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos61"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos61"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos61"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos61"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos61"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos62"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos62"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos62"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos62"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos62"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos63"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos63"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos63"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos63"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos63"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos64"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos64"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos64"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos64"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos64"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong><center>S7</center></strong></td><td align="center"><div id="aplayer-xLQbEJnf" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-xLQbEJnf"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_clean",author:"Yp_S",url:"D12_792_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-ySLWkwae" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-ySLWkwae"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_nb",author:"Yp_S",url:"D12_792_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-wSeNxGbu" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-wSeNxGbu"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_cnnNb_1",author:"Yp_S",url:"D12_792_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-VtwiHQRi" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-VtwiHQRi"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_cnnNb_2",author:"Yp_S",url:"D12_792_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-JPMOIzJm" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-JPMOIzJm"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_cnnNb_3",author:"Yp_S",url:"D12_792_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-igLVGktg" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-igLVGktg"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_cnnNb_4",author:"Yp_S",url:"D12_792_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos71"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos71"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos71"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos71"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos71"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos72"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos72"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos72"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos72"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos72"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos74"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos74"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos74"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos74"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos74"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos73"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos73"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos73"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos73"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos73"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong><center>S8</center></strong></td><td align="center"><div id="aplayer-pIbUEVLy" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-pIbUEVLy"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_clean",author:"Yp_S",url:"D32_786_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-VCzWouGl" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-VCzWouGl"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_nb",author:"Yp_S",url:"D32_786_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-QbrPOhbN" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-QbrPOhbN"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_cnnNb_1",author:"Yp_S",url:"D32_786_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-qFqeJDAS" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-qFqeJDAS"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_cnnNb_2",author:"Yp_S",url:"D32_786_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-UedvddZA" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-UedvddZA"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_cnnNb_3",author:"Yp_S",url:"D32_786_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-NuDkLJuz" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-NuDkLJuz"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_cnnNb_4",author:"Yp_S",url:"D32_786_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos81"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos81"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos81"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos81"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos81"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos82"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos82"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos82"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos82"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos82"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos83"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos83"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos83"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos83"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos83"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T1mos84"><strong>1</strong></label><label><input type="radio" value="2" name="T1mos84"><strong>2</strong></label><label><input type="radio" value="3" name="T1mos84"><strong>3</strong></label><br><label><input type="radio" value="4" name="T1mos84"><strong>4</strong></label><label><input type="radio" value="5" name="T1mos84"><strong>5</strong></label></center></td></tr></tbody></table><h1 id="Test-Table-2-——-Noisy-Narrow-Band"><a href="#Test-Table-2-——-Noisy-Narrow-Band" class="headerlink" title="Test Table 2 —— Noisy Narrow Band"></a><center>Test Table 2 —— Noisy Narrow Band</center></h1><table><thead><tr><th align="center"></th><th align="center"><center>Clean</center></th><th align="center"><center>NB</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th></tr></thead><tbody><tr><td align="center"><strong>S1</strong></td><td align="center"><div id="aplayer-ODWddfZR" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-ODWddfZR"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_clean",author:"Yp_S",url:"D6_763_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-HrBRTwxZ" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-HrBRTwxZ"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_nb",author:"Yp_S",url:"D6_763_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-rRRBBmlx" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-rRRBBmlx"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_cnnNb_1",author:"Yp_S",url:"D6_763_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-YpFKTozW" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-YpFKTozW"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_cnnNb_2",author:"Yp_S",url:"D6_763_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-GfpJbsqN" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-GfpJbsqN"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_cnnNb_3",author:"Yp_S",url:"D6_763_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-akpycVzj" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-akpycVzj"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_763_cnnNb_4",author:"Yp_S",url:"D6_763_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos11"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos11"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos11"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos11"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos11"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos12"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos12"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos12"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos12"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos12"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos13"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos13"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos13"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos13"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos13"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos14"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos14"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos14"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos14"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos14"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong>S2</strong></td><td align="center"><div id="aplayer-rSkXuWxm" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-rSkXuWxm"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_clean",author:"Yp_S",url:"D6_775_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-RmYeZMfP" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-RmYeZMfP"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_nb",author:"Yp_S",url:"D6_775_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-hpjHyXno" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-hpjHyXno"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_cnnNb_1",author:"Yp_S",url:"D6_775_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-YZeoVfEU" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-YZeoVfEU"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_cnnNb_2",author:"Yp_S",url:"D6_775_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-ZRNBgsDs" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-ZRNBgsDs"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_cnnNb_3",author:"Yp_S",url:"D6_775_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-YWlmOaQx" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-YWlmOaQx"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D6_775_cnnNb_4",author:"Yp_S",url:"D6_775_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos21"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos21"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos21"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos21"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos21"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos22"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos22"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos22"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos22"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos22"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos23"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos23"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos23"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos23"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos23"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos24"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos24"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos24"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos24"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos24"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong>S3</strong></td><td align="center"><div id="aplayer-MCpJPCsP" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-MCpJPCsP"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_clean",author:"Yp_S",url:"D7_803_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-IOrOBmGA" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-IOrOBmGA"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_nb",author:"Yp_S",url:"D7_803_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-qFUlEnAN" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-qFUlEnAN"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_cnnNb_1",author:"Yp_S",url:"D7_803_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-GbQiQaet" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-GbQiQaet"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_cnnNb_2",author:"Yp_S",url:"D7_803_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-OFQRfNoO" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-OFQRfNoO"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_cnnNb_3",author:"Yp_S",url:"D7_803_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-uyhcPYyX" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-uyhcPYyX"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D7_803_cnnNb_4",author:"Yp_S",url:"D7_803_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos31"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos31"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos31"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos31"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos31"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos32"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos32"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos32"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos32"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos32"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos33"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos33"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos33"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos33"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos33"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos34"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos34"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos34"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos34"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos34"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong>S4</strong></td><td align="center"><div id="aplayer-EUWqaWVP" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-EUWqaWVP"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_clean",author:"Yp_S",url:"D11_808_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-HUVvlegu" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-HUVvlegu"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_nb",author:"Yp_S",url:"D11_808_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-IXALmxfM" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-IXALmxfM"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_cnnNb_1",author:"Yp_S",url:"D11_808_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-fedTeKFG" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-fedTeKFG"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_cnnNb_2",author:"Yp_S",url:"D11_808_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-cbCaSlhg" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-cbCaSlhg"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_cnnNb_3",author:"Yp_S",url:"D11_808_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-bjicBhCK" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-bjicBhCK"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D11_808_cnnNb_4",author:"Yp_S",url:"D11_808_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos41"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos41"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos41"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos41"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos41"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos42"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos42"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos42"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos42"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos42"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos43"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos43"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos43"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos43"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos43"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos44"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos44"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos44"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos44"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos44"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong>S5</strong></td><td align="center"><div id="aplayer-kUKYLNXx" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-kUKYLNXx"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_clean",author:"Yp_S",url:"D12_770_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-YYPqKTfs" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-YYPqKTfs"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_nb",author:"Yp_S",url:"D12_770_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-uWPyNkEC" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-uWPyNkEC"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_cnnNb_1",author:"Yp_S",url:"D12_770_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-YfhXJcTP" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-YfhXJcTP"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_cnnNb_2",author:"Yp_S",url:"D12_770_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-RtudhjYb" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-RtudhjYb"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_cnnNb_3",author:"Yp_S",url:"D12_770_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-WXZiwsnV" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-WXZiwsnV"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_770_3",author:"Yp_S",url:"D12_770_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos51"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos51"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos51"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos51"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos51"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos52"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos52"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos52"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos52"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos52"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos53"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos53"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos53"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos53"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos53"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos54"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos54"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos54"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos54"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos54"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong>S6</strong></td><td align="center"><div id="aplayer-UsIGjlWK" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-UsIGjlWK"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_clean",author:"Yp_S",url:"D12_780_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-pFjIQkOG" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-pFjIQkOG"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_nb",author:"Yp_S",url:"D12_780_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-ySyBYLTG" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-ySyBYLTG"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_cnnNb_1",author:"Yp_S",url:"D12_780_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-dXWXNukB" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-dXWXNukB"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_cnnNb_2",author:"Yp_S",url:"D12_780_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-eOwwvHwh" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-eOwwvHwh"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_cnnNb_3",author:"Yp_S",url:"D12_780_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-TZhWVINo" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-TZhWVINo"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_780_cnnNb_4",author:"Yp_S",url:"D12_780_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos61"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos61"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos61"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos61"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos61"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos62"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos62"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos62"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos62"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos62"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos63"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos63"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos63"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos63"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos63"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos64"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos64"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos64"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos64"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos64"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong>S7</strong></td><td align="center"><div id="aplayer-WusgWGOm" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-WusgWGOm"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_clean",author:"Yp_S",url:"D12_792_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-VdHDdGwR" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-VdHDdGwR"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_nb",author:"Yp_S",url:"D12_792_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-SaJxdSOs" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-SaJxdSOs"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_cnnNb_1",author:"Yp_S",url:"D12_792_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-amedigFW" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-amedigFW"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_cnnNb_2",author:"Yp_S",url:"D12_792_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-BXauMByl" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-BXauMByl"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_cnnNb_3",author:"Yp_S",url:"D12_792_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-OIekGZhT" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-OIekGZhT"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D12_792_cnnNb_4",author:"Yp_S",url:"D12_792_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos71"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos71"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos71"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos71"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos71"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos72"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos72"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos72"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos72"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos72"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos74"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos74"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos74"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos74"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos74"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos73"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos73"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos73"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos73"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos73"><strong>5</strong></label></center></td></tr><tr><td align="center"><strong>S8</strong></td><td align="center"><div id="aplayer-GBNVyRfj" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-GBNVyRfj"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_clean",author:"Yp_S",url:"D32_786_clean.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-zZGmEQkj" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-zZGmEQkj"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_nb",author:"Yp_S",url:"D32_786_nb.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-KZCfvnTr" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-KZCfvnTr"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_cnnNb_1",author:"Yp_S",url:"D32_786_cnnNb_entropyloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-MrzMCXdc" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-MrzMCXdc"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_cnnNb_2",author:"Yp_S",url:"D32_786_cnnNb_mpegloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-wkKpbvMU" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-wkKpbvMU"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_cnnNb_3",author:"Yp_S",url:"D32_786_cnnNb_mseloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td><td align="center"><div id="aplayer-RmrJVwJk" class="aplayer aplayer-tag-marker" style="margin-bottom:20px"><pre class="aplayer-lrc-content"></pre></div><script>var ap=new APlayer({element:document.getElementById("aplayer-RmrJVwJk"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:"D32_786_cnnNb_4",author:"Yp_S",url:"D32_786_cnnNb_perceptualloss.wav",pic:"",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></td></tr><tr><td align="center"><center><strong>MOS</strong></center></td><td align="center"><center><strong>Reference</strong></center></td><td align="center"><center><strong>1</strong></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos81"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos81"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos81"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos81"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos81"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos82"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos82"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos82"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos82"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos82"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos83"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos83"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos83"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos83"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos83"><strong>5</strong></label></center></td><td align="center"><center><label><input type="radio" value="1" name="T2mos84"><strong>1</strong></label><label><input type="radio" value="2" name="T2mos84"><strong>2</strong></label><label><input type="radio" value="3" name="T2mos84"><strong>3</strong></label><br><label><input type="radio" value="4" name="T2mos84"><strong>4</strong></label><label><input type="radio" value="5" name="T2mos84"><strong>5</strong></label></center></td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【图解】随机采样 &amp; 相邻采样</title>
    <link href="http://yoursite.com/2020/02/21/sample2png/"/>
    <id>http://yoursite.com/2020/02/21/sample2png/</id>
    <published>2020-02-20T16:44:00.139Z</published>
    <updated>2020-02-20T16:17:57.114Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="【图解】随机采样-amp-相邻采样"><a href="#【图解】随机采样-amp-相邻采样" class="headerlink" title="【图解】随机采样 &amp; 相邻采样"></a>【图解】随机采样 &amp; 相邻采样</h1><p>本系列主要针对深度学习过程中的零碎知识点整理与直观理解。</p><h2 id="先验知识："><a href="#先验知识：" class="headerlink" title="先验知识："></a>先验知识：</h2><p>采样序列总字符长度：$L$</p><p>批量大小（每个批量中的样本数）：<code>batch_size = n</code></p><p>每个样本包含的时间步：<code>num_step = t</code></p><p><strong>小批量采样</strong>：每次只处理一个批量的样本，每个字符最多只能出现在一个样本中。</p><p><strong><em>【重点】：</em></strong>随机和相邻均指相邻<strong>批量</strong>之间！</p><p>由序列总长与样本时间步可知样本数为：$N = \lfloor \frac{L}{t} \rfloor$ （向下取整，舍弃）</p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="E:%5CBlog%5Csource_posts%5Csample2pngsample1.png" alt="image 1"></p><p><img src="E:%5CBlog%5Csource_posts%5Csample2pngsample2.png" alt="image 2"></p><p><img src="E:%5CBlog%5Csource_posts%5Csample2pngsample3.png" alt="image 3"></p><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><p><a href="https://seventeenchen.github.io/2020/02/15/sample/" target="_blank" rel="noopener">代码页面</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="图解深度学习" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="序列采样" scheme="http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E9%87%87%E6%A0%B7/"/>
    
      <category term="随机采样" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"/>
    
      <category term="相邻采样" scheme="http://yoursite.com/tags/%E7%9B%B8%E9%82%BB%E9%87%87%E6%A0%B7/"/>
    
      <category term="图解" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Task1.10 机器翻译和数据集</title>
    <link href="http://yoursite.com/2020/02/20/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/"/>
    <id>http://yoursite.com/2020/02/20/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/</id>
    <published>2020-02-20T13:43:15.663Z</published>
    <updated>2020-02-20T13:34:02.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="机器翻译和数据集"><a href="#机器翻译和数据集" class="headerlink" title="机器翻译和数据集"></a>机器翻译和数据集</h1><p>机器翻译（MT）：将一段文本从一种语言自动翻译为另一种语言，用神经网络解决这个问题通常称为神经机器翻译（NMT）。<br>主要特征：输出是单词序列而不是单个单词。 输出序列的长度可能与源序列的长度不同。<br>不能用传统RNN实现，机器翻译输出于输入序列长度可能不一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.listdir(<span class="string">'/home/kesci/input/'</span>)</span><br></pre></td></tr></table></figure><pre><code>[&apos;fraeng6506&apos;, &apos;d2l9528&apos;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'/home/kesci/input/d2l9528/'</span>)</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> d2l</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">from</span> d2l.data.base <span class="keyword">import</span> Vocab</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br></pre></td></tr></table></figure><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>将数据集清洗、转化为神经网络的输入minbatch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/home/kesci/input/fraeng6506/fra.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">      raw_text = f.read()</span><br><span class="line">print(raw_text[<span class="number">0</span>:<span class="number">1000</span>])</span><br></pre></td></tr></table></figure><pre><code>Go.    Va !    CC-BY 2.0 (France) Attribution: tatoeba.org #2877272 (CM) &amp; #1158250 (Wittydev)Hi.    Salut !    CC-BY 2.0 (France) Attribution: tatoeba.org #538123 (CM) &amp; #509819 (Aiji)Hi.    Salut.    CC-BY 2.0 (France) Attribution: tatoeba.org #538123 (CM) &amp; #4320462 (gillux)Run!    Cours !    CC-BY 2.0 (France) Attribution: tatoeba.org #906328 (papabear) &amp; #906331 (sacredceltic)Run!    Courez !    CC-BY 2.0 (France) Attribution: tatoeba.org #906328 (papabear) &amp; #906332 (sacredceltic)Who?    Qui ?    CC-BY 2.0 (France) Attribution: tatoeba.org #2083030 (CK) &amp; #4366796 (gillux)Wow!    Ça alors !    CC-BY 2.0 (France) Attribution: tatoeba.org #52027 (Zifre) &amp; #374631 (zmoo)Fire!    Au feu !    CC-BY 2.0 (France) Attribution: tatoeba.org #1829639 (Spamster) &amp; #4627939 (sacredceltic)Help!    À l&apos;aide !    CC-BY 2.0 (France) Attribution: tatoeba.org #435084 (lukaszpp) &amp; #128430 (sysko)Jump.    Saute.    CC-BY 2.0 (France) Attribution: tatoeba.org #631038 (Shishir) &amp; #2416938 (Phoenix)Stop!    Ça suffit !    CC-BY 2.0 (France) Attribution: tato</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_raw</span><span class="params">(text)</span>:</span></span><br><span class="line">    text = text.replace(<span class="string">'\u202f'</span>, <span class="string">' '</span>).replace(<span class="string">'\xa0'</span>, <span class="string">' '</span>) <span class="comment"># 空格，去掉乱码</span></span><br><span class="line">    out = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(text.lower()): </span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> (<span class="string">','</span>, <span class="string">'!'</span>, <span class="string">'.'</span>) <span class="keyword">and</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> text[i<span class="number">-1</span>] != <span class="string">' '</span>:</span><br><span class="line">            out += <span class="string">' '</span></span><br><span class="line">        out += char</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">text = preprocess_raw(raw_text)</span><br><span class="line">print(text[<span class="number">0</span>:<span class="number">1000</span>])</span><br></pre></td></tr></table></figure><pre><code>go .    va !    cc-by 2 .0 (france) attribution: tatoeba .org #2877272 (cm) &amp; #1158250 (wittydev)hi .    salut !    cc-by 2 .0 (france) attribution: tatoeba .org #538123 (cm) &amp; #509819 (aiji)hi .    salut .    cc-by 2 .0 (france) attribution: tatoeba .org #538123 (cm) &amp; #4320462 (gillux)run !    cours !    cc-by 2 .0 (france) attribution: tatoeba .org #906328 (papabear) &amp; #906331 (sacredceltic)run !    courez !    cc-by 2 .0 (france) attribution: tatoeba .org #906328 (papabear) &amp; #906332 (sacredceltic)who?    qui ?    cc-by 2 .0 (france) attribution: tatoeba .org #2083030 (ck) &amp; #4366796 (gillux)wow !    ça alors !    cc-by 2 .0 (france) attribution: tatoeba .org #52027 (zifre) &amp; #374631 (zmoo)fire !    au feu !    cc-by 2 .0 (france) attribution: tatoeba .org #1829639 (spamster) &amp; #4627939 (sacredceltic)help !    à l&apos;aide !    cc-by 2 .0 (france) attribution: tatoeba .org #435084 (lukaszpp) &amp; #128430 (sysko)jump .    saute .    cc-by 2 .0 (france) attribution: tatoeba .org #631038 (shishir) &amp; #2416938 (phoenix)stop !    ça suffit !    cc-b</code></pre><p>字符在计算机里是以编码的形式存在，我们通常所用的空格是 \x20 ，是在标准ASCII可见字符 0x20~0x7e 范围内。<br>而 \xa0 属于 latin1 （ISO/IEC_8859-1）中的扩展字符集字符，代表不间断空白符nbsp(non-breaking space)，超出gbk编码范围，是需要去除的特殊字符。再数据预处理的过程中，我们首先需要对数据进行清洗。</p><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>字符串—单词组成的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num_examples = <span class="number">50000</span></span><br><span class="line">source, target = [], []</span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> enumerate(text.split(<span class="string">'\n'</span>)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; num_examples:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    parts = line.split(<span class="string">'\t'</span>)</span><br><span class="line">    <span class="keyword">if</span> len(parts) &gt;= <span class="number">2</span>:</span><br><span class="line">        source.append(parts[<span class="number">0</span>].split(<span class="string">' '</span>))</span><br><span class="line">        target.append(parts[<span class="number">1</span>].split(<span class="string">' '</span>))</span><br><span class="line">        </span><br><span class="line">source[<span class="number">0</span>:<span class="number">3</span>], target[<span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><pre><code>([[&apos;go&apos;, &apos;.&apos;], [&apos;hi&apos;, &apos;.&apos;], [&apos;hi&apos;, &apos;.&apos;]], [[&apos;va&apos;, &apos;!&apos;], [&apos;salut&apos;, &apos;!&apos;], [&apos;salut&apos;, &apos;.&apos;]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d2l.set_figsize()</span><br><span class="line">d2l.plt.hist([[len(l) <span class="keyword">for</span> l <span class="keyword">in</span> source], [len(l) <span class="keyword">for</span> l <span class="keyword">in</span> target]],label=[<span class="string">'source'</span>, <span class="string">'target'</span>])</span><br><span class="line">d2l.plt.legend(loc=<span class="string">'upper right'</span>);</span><br></pre></td></tr></table></figure><img src="https://cdn.kesci.com/rt_upload/7589E7D345B3463A8F0F4574ED6EDA9A/q604m8iec7.svg"><h3 id="建立词典"><a href="#建立词典" class="headerlink" title="建立词典"></a>建立词典</h3><p>单词组成的列表—单词id组成的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_vocab</span><span class="params">(tokens)</span>:</span></span><br><span class="line">    tokens = [token <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line] <span class="comment"># 单词列表</span></span><br><span class="line">    <span class="keyword">return</span> d2l.data.base.Vocab(tokens, min_freq=<span class="number">3</span>, use_special_tokens=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">src_vocab = build_vocab(source)</span><br><span class="line">len(src_vocab)</span><br></pre></td></tr></table></figure><pre><code>3789</code></pre><p><img src="https://cdn.kesci.com/upload/image/q5jc5ga5gy.png?imageView2/0/w/960/h/960" alt="Image Name"></p><h3 id="载入数据集"><a href="#载入数据集" class="headerlink" title="载入数据集"></a>载入数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span><span class="params">(line, max_len, padding_token)</span>:</span> <span class="comment"># 保证句子长度一致</span></span><br><span class="line">    <span class="keyword">if</span> len(line) &gt; max_len:</span><br><span class="line">        <span class="keyword">return</span> line[:max_len]</span><br><span class="line">    <span class="keyword">return</span> line + [padding_token] * (max_len - len(line))</span><br><span class="line">pad(src_vocab[source[<span class="number">0</span>]], <span class="number">10</span>, src_vocab.pad)</span><br></pre></td></tr></table></figure><pre><code>[38, 4, 0, 0, 0, 0, 0, 0, 0, 0]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_array</span><span class="params">(lines, vocab, max_len, is_source)</span>:</span> </span><br><span class="line">    lines = [vocab[line] <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_source:</span><br><span class="line">        lines = [[vocab.bos] + line + [vocab.eos] <span class="keyword">for</span> line <span class="keyword">in</span> lines] <span class="comment"># target </span></span><br><span class="line">    array = torch.tensor([pad(line, max_len, vocab.pad) <span class="keyword">for</span> line <span class="keyword">in</span> lines]) <span class="comment"># list 2 tensor</span></span><br><span class="line">    valid_len = (array != vocab.pad).sum(<span class="number">1</span>) <span class="comment">#第一个维度 有效长度</span></span><br><span class="line">    <span class="keyword">return</span> array, valid_len <span class="comment"># valid_len: 句子数量， array：句子数量 * 长度 max_len</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.kesci.com/upload/image/q5jc6e5tt1.png?imageView2/0/w/960/h/960" alt="Image Name"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data_nmt</span><span class="params">(batch_size, max_len)</span>:</span> <span class="comment"># This function is saved in d2l.</span></span><br><span class="line">    src_vocab, tgt_vocab = build_vocab(source), build_vocab(target)</span><br><span class="line">    src_array, src_valid_len = build_array(source, src_vocab, max_len, <span class="literal">True</span>)</span><br><span class="line">    tgt_array, tgt_valid_len = build_array(target, tgt_vocab, max_len, <span class="literal">False</span>)</span><br><span class="line">    train_data = data.TensorDataset(src_array, src_valid_len, tgt_array, tgt_valid_len) <span class="comment"># 用来判断一一对应，第一维，第零维</span></span><br><span class="line">    train_iter = data.DataLoader(train_data, batch_size, shuffle=<span class="literal">True</span>) <span class="comment"># 数据生成器</span></span><br><span class="line">    <span class="keyword">return</span> src_vocab, tgt_vocab, train_iter</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src_vocab, tgt_vocab, train_iter = load_data_nmt(batch_size=<span class="number">2</span>, max_len=<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> X, X_valid_len, Y, Y_valid_len, <span class="keyword">in</span> train_iter:</span><br><span class="line">    print(<span class="string">'X ='</span>, X.type(torch.int32), <span class="string">'\nValid lengths for X ='</span>, X_valid_len,</span><br><span class="line">        <span class="string">'\nY ='</span>, Y.type(torch.int32), <span class="string">'\nValid lengths for Y ='</span>, Y_valid_len)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><pre><code>X = tensor([[  63,   16,    6,   59, 2805,    0,    0,    0],        [   5,   78,   20,  613,    4,    0,    0,    0]], dtype=torch.int32) Valid lengths for X = tensor([5, 5]) Y = tensor([[  1,  66,  98,  75, 895,   6,   2,   0],        [  1,   5, 100,  22,  10,  35, 810,   4]], dtype=torch.int32) Valid lengths for Y = tensor([7, 8])</code></pre><h1 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder-Decoder"></a>Encoder-Decoder</h1><p>encoder：输入到隐藏状态<br>decoder：隐藏状态到输出</p><p><img src="https://cdn.kesci.com/upload/image/q5jcat3c8m.png?imageView2/0/w/640/h/640" alt="Image Name"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(Encoder, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, X, *args)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(Decoder, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_state</span><span class="params">(self, enc_outputs, *args)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, X, state)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderDecoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, encoder, decoder, **kwargs)</span>:</span></span><br><span class="line">        super(EncoderDecoder, self).__init__(**kwargs)</span><br><span class="line">        self.encoder = encoder</span><br><span class="line">        self.decoder = decoder</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, enc_X, dec_X, *args)</span>:</span></span><br><span class="line">        enc_outputs = self.encoder(enc_X, *args)</span><br><span class="line">        dec_state = self.decoder.init_state(enc_outputs, *args)</span><br><span class="line">        <span class="keyword">return</span> self.decoder(dec_X, dec_state)</span><br></pre></td></tr></table></figure><p>可以应用在对话系统、生成式任务中。</p><h1 id="Sequence-to-Sequence模型"><a href="#Sequence-to-Sequence模型" class="headerlink" title="Sequence to Sequence模型"></a>Sequence to Sequence模型</h1><h3 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h3><p>训练<br><img src="https://cdn.kesci.com/upload/image/q5jc7a53pt.png?imageView2/0/w/640/h/640" alt="Image Name"><br>预测</p><p><img src="https://cdn.kesci.com/upload/image/q5jcecxcba.png?imageView2/0/w/640/h/640" alt="Image Name"></p><h3 id="具体结构："><a href="#具体结构：" class="headerlink" title="具体结构："></a>具体结构：</h3><p><img src="https://cdn.kesci.com/upload/image/q5jccjhkii.png?imageView2/0/w/500/h/500" alt="Image Name"></p><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seq2SeqEncoder</span><span class="params">(d2l.Encoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocab_size, embed_size, num_hiddens, num_layers,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dropout=<span class="number">0</span>, **kwargs)</span>:</span></span><br><span class="line">        super(Seq2SeqEncoder, self).__init__(**kwargs)</span><br><span class="line">        self.num_hiddens=num_hiddens</span><br><span class="line">        self.num_layers=num_layers</span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        self.rnn = nn.LSTM(embed_size,num_hiddens, num_layers, dropout=dropout)</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin_state</span><span class="params">(self, batch_size, device)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [torch.zeros(size=(self.num_layers, batch_size, self.num_hiddens),  device=device),</span><br><span class="line">                torch.zeros(size=(self.num_layers, batch_size, self.num_hiddens),  device=device)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, X, *args)</span>:</span></span><br><span class="line">        X = self.embedding(X) <span class="comment"># X shape: (batch_size, seq_len, embed_size)</span></span><br><span class="line">        X = X.transpose(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># RNN needs first axes to be time</span></span><br><span class="line">        <span class="comment"># state = self.begin_state(X.shape[1], device=X.device)</span></span><br><span class="line">        out, state = self.rnn(X)</span><br><span class="line">        <span class="comment"># The shape of out is (seq_len, batch_size, num_hiddens).</span></span><br><span class="line">        <span class="comment"># state contains the hidden state and the memory cell</span></span><br><span class="line">        <span class="comment"># of the last time step, the shape is (num_layers, batch_size, num_hiddens)</span></span><br><span class="line">        <span class="keyword">return</span> out, state</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">encoder = Seq2SeqEncoder(vocab_size=<span class="number">10</span>, embed_size=<span class="number">8</span>,num_hiddens=<span class="number">16</span>, num_layers=<span class="number">2</span>)</span><br><span class="line">X = torch.zeros((<span class="number">4</span>, <span class="number">7</span>),dtype=torch.long)</span><br><span class="line">output, state = encoder(X)</span><br><span class="line">output.shape, len(state), state[<span class="number">0</span>].shape, state[<span class="number">1</span>].shape</span><br></pre></td></tr></table></figure><pre><code>(torch.Size([7, 4, 16]), 2, torch.Size([2, 4, 16]), torch.Size([2, 4, 16]))</code></pre><h1 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seq2SeqDecoder</span><span class="params">(d2l.Decoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocab_size, embed_size, num_hiddens, num_layers,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dropout=<span class="number">0</span>, **kwargs)</span>:</span></span><br><span class="line">        super(Seq2SeqDecoder, self).__init__(**kwargs)</span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        self.rnn = nn.LSTM(embed_size,num_hiddens, num_layers, dropout=dropout)</span><br><span class="line">        self.dense = nn.Linear(num_hiddens,vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_state</span><span class="params">(self, enc_outputs, *args)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> enc_outputs[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, X, state)</span>:</span></span><br><span class="line">        X = self.embedding(X).transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        out, state = self.rnn(X, state)</span><br><span class="line">        <span class="comment"># Make the batch to be the first dimension to simplify loss computation.</span></span><br><span class="line">        out = self.dense(out).transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> out, state</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decoder = Seq2SeqDecoder(vocab_size=<span class="number">10</span>, embed_size=<span class="number">8</span>,num_hiddens=<span class="number">16</span>, num_layers=<span class="number">2</span>)</span><br><span class="line">state = decoder.init_state(encoder(X))</span><br><span class="line">out, state = decoder(X, state)</span><br><span class="line">out.shape, len(state), state[<span class="number">0</span>].shape, state[<span class="number">1</span>].shape</span><br></pre></td></tr></table></figure><pre><code>(torch.Size([4, 7, 10]), 2, torch.Size([2, 4, 16]), torch.Size([2, 4, 16]))</code></pre><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SequenceMask</span><span class="params">(X, X_len,value=<span class="number">0</span>)</span>:</span><span class="comment"># X：一个batch的输入（损失），X_len：有效长度</span></span><br><span class="line">    maxlen = X.size(<span class="number">1</span>)</span><br><span class="line">    mask = torch.arange(maxlen)[<span class="literal">None</span>, :].to(X_len.device) &lt; X_len[:, <span class="literal">None</span>]   </span><br><span class="line">    X[~mask]=value</span><br><span class="line">    <span class="keyword">return</span> X</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">SequenceMask(X,torch.tensor([<span class="number">1</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><pre><code>tensor([[1, 0, 0],        [4, 5, 0]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = torch.ones((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">SequenceMask(X, torch.tensor([<span class="number">1</span>,<span class="number">2</span>]),value=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[ 1.,  1.,  1.,  1.],         [-1., -1., -1., -1.],         [-1., -1., -1., -1.]],        [[ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [-1., -1., -1., -1.]]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaskedSoftmaxCELoss</span><span class="params">(nn.CrossEntropyLoss)</span>:</span></span><br><span class="line">    <span class="comment"># pred shape: (batch_size, seq_len, vocab_size)</span></span><br><span class="line">    <span class="comment"># label shape: (batch_size, seq_len) 只记录得分最高的单词</span></span><br><span class="line">    <span class="comment"># valid_length shape: (batch_size, )</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, pred, label, valid_length)</span>:</span></span><br><span class="line">        <span class="comment"># the sample weights shape should be (batch_size, seq_len)</span></span><br><span class="line">        weights = torch.ones_like(label)</span><br><span class="line">        weights = SequenceMask(weights, valid_length).float()</span><br><span class="line">        self.reduction=<span class="string">'none'</span></span><br><span class="line">        output=super(MaskedSoftmaxCELoss, self).forward(pred.transpose(<span class="number">1</span>,<span class="number">2</span>), label)</span><br><span class="line">        <span class="keyword">return</span> (output*weights).mean(dim=<span class="number">1</span>) <span class="comment"># 第一维：每个单词</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss = MaskedSoftmaxCELoss()</span><br><span class="line">loss(torch.ones((<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>)), torch.ones((<span class="number">3</span>,<span class="number">4</span>),dtype=torch.long), torch.tensor([<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><pre><code>tensor([2.3026, 1.7269, 0.0000])</code></pre><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_ch7</span><span class="params">(model, data_iter, lr, num_epochs, device)</span>:</span>  <span class="comment"># Saved in d2l</span></span><br><span class="line">    model.to(device)</span><br><span class="line">    optimizer = optim.Adam(model.parameters(), lr=lr)</span><br><span class="line">    loss = MaskedSoftmaxCELoss()</span><br><span class="line">    tic = time.time()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, num_epochs+<span class="number">1</span>):</span><br><span class="line">        l_sum, num_tokens_sum = <span class="number">0.0</span>, <span class="number">0.0</span> <span class="comment"># 当前epoch loss总和</span></span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> data_iter:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            X, X_vlen, Y, Y_vlen = [x.to(device) <span class="keyword">for</span> x <span class="keyword">in</span> batch] <span class="comment"># Y： bos + word + eos</span></span><br><span class="line">            Y_input, Y_label, Y_vlen = Y[:,:<span class="number">-1</span>], Y[:,<span class="number">1</span>:], Y_vlen<span class="number">-1</span></span><br><span class="line">             <span class="comment"># Y_imput: bos+ word ,  </span></span><br><span class="line">             <span class="comment"># Y_lavel: ground truth word + eos</span></span><br><span class="line">            </span><br><span class="line">            Y_hat, _ = model(X, Y_input, X_vlen, Y_vlen)</span><br><span class="line">            l = loss(Y_hat, Y_label, Y_vlen).sum()</span><br><span class="line">            l.backward()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> torch.no_grad(): <span class="comment"># 梯度裁剪</span></span><br><span class="line">                d2l.grad_clipping_nn(model, <span class="number">5</span>, device)</span><br><span class="line">            num_tokens = Y_vlen.sum().item()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            l_sum += l.sum().item()</span><br><span class="line">            num_tokens_sum += num_tokens</span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"epoch &#123;0:4d&#125;,loss &#123;1:.3f&#125;, time &#123;2:.1f&#125; sec"</span>.format( </span><br><span class="line">                  epoch, (l_sum/num_tokens_sum), time.time()-tic))</span><br><span class="line">            tic = time.time()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">embed_size, num_hiddens, num_layers, dropout = <span class="number">32</span>, <span class="number">32</span>, <span class="number">2</span>, <span class="number">0.0</span></span><br><span class="line">batch_size, num_examples, max_len = <span class="number">64</span>, <span class="number">1e3</span>, <span class="number">10</span></span><br><span class="line">lr, num_epochs, ctx = <span class="number">0.005</span>, <span class="number">300</span>, d2l.try_gpu()</span><br><span class="line">src_vocab, tgt_vocab, train_iter = d2l.load_data_nmt(</span><br><span class="line">    batch_size, max_len,num_examples)</span><br><span class="line">encoder = Seq2SeqEncoder(</span><br><span class="line">    len(src_vocab), embed_size, num_hiddens, num_layers, dropout)</span><br><span class="line">decoder = Seq2SeqDecoder(</span><br><span class="line">    len(tgt_vocab), embed_size, num_hiddens, num_layers, dropout)</span><br><span class="line">model = d2l.EncoderDecoder(encoder, decoder)</span><br><span class="line">train_ch7(model, train_iter, lr, num_epochs, ctx)</span><br></pre></td></tr></table></figure><pre><code>epoch   50,loss 0.096, time 34.0 secepoch  100,loss 0.047, time 34.7 secepoch  150,loss 0.032, time 33.4 secepoch  200,loss 0.027, time 32.9 secepoch  250,loss 0.026, time 34.3 secepoch  300,loss 0.024, time 33.9 sec</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate_ch7</span><span class="params">(model, src_sentence, src_vocab, tgt_vocab, max_len, device)</span>:</span></span><br><span class="line">    src_tokens = src_vocab[src_sentence.lower().split(<span class="string">' '</span>)]</span><br><span class="line">    src_len = len(src_tokens)</span><br><span class="line">    <span class="keyword">if</span> src_len &lt; max_len:</span><br><span class="line">        src_tokens += [src_vocab.pad] * (max_len - src_len)</span><br><span class="line">    enc_X = torch.tensor(src_tokens, device=device)</span><br><span class="line">    enc_valid_length = torch.tensor([src_len], device=device)</span><br><span class="line">    <span class="comment"># use expand_dim to add the batch_size dimension.</span></span><br><span class="line">    enc_outputs = model.encoder(enc_X.unsqueeze(dim=<span class="number">0</span>), enc_valid_length)</span><br><span class="line">    dec_state = model.decoder.init_state(enc_outputs, enc_valid_length)</span><br><span class="line">    dec_X = torch.tensor([tgt_vocab.bos], device=device).unsqueeze(dim=<span class="number">0</span>)</span><br><span class="line">    predict_tokens = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_len):</span><br><span class="line">        Y, dec_state = model.decoder(dec_X, dec_state)</span><br><span class="line">        <span class="comment"># The token with highest score is used as the next time step input.</span></span><br><span class="line">        dec_X = Y.argmax(dim=<span class="number">2</span>)</span><br><span class="line">        py = dec_X.squeeze(dim=<span class="number">0</span>).int().item()</span><br><span class="line">        <span class="keyword">if</span> py == tgt_vocab.eos:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        predict_tokens.append(py)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(tgt_vocab.to_tokens(predict_tokens))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> [<span class="string">'Go .'</span>, <span class="string">'Wow !'</span>, <span class="string">"I'm OK ."</span>, <span class="string">'I won !'</span>]:</span><br><span class="line">    print(sentence + <span class="string">' =&gt; '</span> + translate_ch7(</span><br><span class="line">        model, sentence, src_vocab, tgt_vocab, max_len, ctx))</span><br></pre></td></tr></table></figure><pre><code>Go . =&gt; va !Wow ! =&gt; &lt;unk&gt; !I&apos;m OK . =&gt; je vais bien .I won ! =&gt; j&apos;ai gagné !</code></pre><h1 id="Beam-Search"><a href="#Beam-Search" class="headerlink" title="Beam Search"></a>Beam Search</h1><p>简单greedy search：</p><p><img src="https://cdn.kesci.com/upload/image/q5jchqoppn.png?imageView2/0/w/440/h/440" alt="Image Name"></p><p>维特比算法：选择整体分数最高的句子（搜索空间太大）<br>集束搜索：</p><p><img src="https://cdn.kesci.com/upload/image/q5jcia86z1.png?imageView2/0/w/640/h/640" alt="Image Name"></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="深度学习实战" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
      <category term="机器翻译" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Encoder-Decoder" scheme="http://yoursite.com/tags/Encoder-Decoder/"/>
    
      <category term="seq2seq model" scheme="http://yoursite.com/tags/seq2seq-model/"/>
    
      <category term="Beam Search" scheme="http://yoursite.com/tags/Beam-Search/"/>
    
  </entry>
  
  <entry>
    <title>Task1.9 RNN 进阶</title>
    <link href="http://yoursite.com/2020/02/20/ModernRNN/"/>
    <id>http://yoursite.com/2020/02/20/ModernRNN/</id>
    <published>2020-02-20T13:38:44.865Z</published>
    <updated>2020-02-20T13:39:54.394Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h1><p>RNN存在的问题：梯度较容易出现衰减或爆炸（BPTT）<br>⻔控循环神经⽹络：捕捉时间序列中时间步距离较⼤的依赖关系<br><strong>RNN</strong>:</p><p><img src="https://cdn.kesci.com/upload/image/q5jjvcykud.png?imageView2/0/w/320/h/320" alt="Image Name"></p><p>$$<br>H_{t} = ϕ(X_{t}W_{xh} + H_{t-1}W_{hh} + b_{h})<br>$$<br><strong>GRU</strong>:</p><p><img src="https://cdn.kesci.com/upload/image/q5jk0q9suq.png?imageView2/0/w/640/h/640" alt="Image Name"></p><p>$$<br>R_{t} = σ(X_tW_{xr} + H_{t−1}W_{hr} + b_r)\<br>Z_{t} = σ(X_tW_{xz} + H_{t−1}W_{hz} + b_z)\<br>\widetilde{H}<em>t = tanh(X_tW</em>{xh} + (R_t ⊙H_{t−1})W_{hh} + b_h)\<br>H_t = Z_t⊙H_{t−1} + (1−Z_t)⊙\widetilde{H}_t<br>$$<br>• 重置⻔有助于捕捉时间序列⾥短期的依赖关系；<br>• 更新⻔有助于捕捉时间序列⾥⻓期的依赖关系。</p><h3 id="载入数据集"><a href="#载入数据集" class="headerlink" title="载入数据集"></a>载入数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.listdir(<span class="string">'/home/kesci/input'</span>)</span><br></pre></td></tr></table></figure><pre><code>[&apos;d2lzh1981&apos;, &apos;houseprices2807&apos;, &apos;jaychou_lyrics4703&apos;, &apos;d2l_jay9460&apos;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"../input/"</span>)</span><br><span class="line"><span class="keyword">import</span> d2l_jay9460 <span class="keyword">as</span> d2l</span><br><span class="line">device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line"></span><br><span class="line">(corpus_indices, char_to_idx, idx_to_char, vocab_size) = d2l.load_data_jay_lyrics()</span><br></pre></td></tr></table></figure><h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">num_inputs, num_hiddens, num_outputs = vocab_size, <span class="number">256</span>, vocab_size</span><br><span class="line">print(<span class="string">'will use'</span>, device)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_one</span><span class="params">(shape)</span>:</span></span><br><span class="line">        ts = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=shape), device=device, dtype=torch.float32) <span class="comment">#正态分布 </span></span><br><span class="line">        <span class="comment"># 0均值 var = 0.01</span></span><br><span class="line">        <span class="keyword">return</span> torch.nn.Parameter(ts, requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_three</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (_one((num_inputs, num_hiddens)), </span><br><span class="line">                _one((num_hiddens, num_hiddens)),</span><br><span class="line">                torch.nn.Parameter(torch.zeros(num_hiddens, device=device, dtype=torch.float32), requires_grad=<span class="literal">True</span>))</span><br><span class="line">     </span><br><span class="line">    W_xz, W_hz, b_z = _three()  <span class="comment"># 更新门参数</span></span><br><span class="line">    W_xr, W_hr, b_r = _three()  <span class="comment"># 重置门参数</span></span><br><span class="line">    W_xh, W_hh, b_h = _three()  <span class="comment"># 候选隐藏状态参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = _one((num_hiddens, num_outputs))</span><br><span class="line">    b_q = torch.nn.Parameter(torch.zeros(num_outputs, device=device, dtype=torch.float32), requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> nn.ParameterList([W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q]) <span class="comment"># 11 paras</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_gru_state</span><span class="params">(batch_size, num_hiddens, device)</span>:</span>   <span class="comment">#隐藏状态初始化</span></span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device), )</span><br></pre></td></tr></table></figure><pre><code>will use cpu</code></pre><h3 id="GRU模型"><a href="#GRU模型" class="headerlink" title="GRU模型"></a>GRU模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gru</span><span class="params">(inputs, state, params)</span>:</span></span><br><span class="line">    W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q = params</span><br><span class="line">    H, = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        Z = torch.sigmoid(torch.matmul(X, W_xz) + torch.matmul(H, W_hz) + b_z)</span><br><span class="line">        R = torch.sigmoid(torch.matmul(X, W_xr) + torch.matmul(H, W_hr) + b_r)</span><br><span class="line">        H_tilda = torch.tanh(torch.matmul(X, W_xh) + R * torch.matmul(H, W_hh) + b_h)</span><br><span class="line">        H = Z * H + (<span class="number">1</span> - Z) * H_tilda</span><br><span class="line">        Y = torch.matmul(H, W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> outputs, (H,)</span><br></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, num_steps, batch_size, lr, clipping_theta = <span class="number">160</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">1e2</span>, <span class="number">1e-2</span></span><br><span class="line">pred_period, pred_len, prefixes = <span class="number">40</span>, <span class="number">50</span>, [<span class="string">'分开'</span>, <span class="string">'不分开'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d2l.train_and_predict_rnn(gru, get_params, init_gru_state, num_hiddens,</span><br><span class="line">                          vocab_size, device, corpus_indices, idx_to_char,</span><br><span class="line">                          char_to_idx, <span class="literal">False</span>, num_epochs, num_steps, lr,</span><br><span class="line">                          clipping_theta, batch_size, pred_period, pred_len,</span><br><span class="line">                          prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 40, perplexity 152.268495, time 1.31 sec - 分开 我想你你 我不这 我不不 我想你你 我不这 我不不 我想你你 我不这 我不不 我想你你 我不这 我 - 不分开 我想你你 我不这 我不不 我想你你 我不这 我不不 我想你你 我不这 我不不 我想你你 我不这 我epoch 80, perplexity 32.902482, time 1.29 sec - 分开 一直在人截棍 哼哼哈兮 快使用双截棍 哼哼哈兮 快使用双截棍 哼哼哈兮 快使用双截棍 哼哼哈兮 快 - 不分开 你爱我 别你 我想要这样 我不要再想 我不要再想 我不要再想 我不要再想 我不要再想 我不要再想 epoch 120, perplexity 5.031946, time 1.26 sec - 分开 一直心酒 你的完空 恨谁风空  没有用双截棍 哼哼哈兮 快使用双截棍 哼哼哈兮 快使用双截棍 哼哼 - 不分开 爱过走的太快就像龙卷风 不能再能我 再你这这不舍 后知后觉 我跟了这节奏 我该好好生活 不知不觉 epoch 160, perplexity 1.491664, time 1.31 sec - 分开 我想想这样的脑袋有问题 随便说说 其实我早已经猜透看透不想多说 只是我怕眼泪撑不住 不懂 你的黑色 - 不分开 你已经离开我 不知不觉 我跟了这节奏 后知后觉 又过了一个秋 后知后觉 我该好好生活 我该好好生活</code></pre><h3 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num_hiddens=<span class="number">256</span></span><br><span class="line">num_epochs, num_steps, batch_size, lr, clipping_theta = <span class="number">160</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">1e2</span>, <span class="number">1e-2</span></span><br><span class="line">pred_period, pred_len, prefixes = <span class="number">40</span>, <span class="number">50</span>, [<span class="string">'分开'</span>, <span class="string">'不分开'</span>]</span><br><span class="line"></span><br><span class="line">lr = <span class="number">1e-2</span> <span class="comment"># 注意调整学习率</span></span><br><span class="line">gru_layer = nn.GRU(input_size=vocab_size, hidden_size=num_hiddens)</span><br><span class="line">model = d2l.RNNModel(gru_layer, vocab_size).to(device)</span><br><span class="line">d2l.train_and_predict_rnn_pytorch(model, num_hiddens, vocab_size, device,</span><br><span class="line">                                corpus_indices, idx_to_char, char_to_idx,</span><br><span class="line">                                num_epochs, num_steps, lr, clipping_theta,</span><br><span class="line">                                batch_size, pred_period, pred_len, prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 40, perplexity 1.018378, time 0.95 sec - 分开的玩笑 想通 却又再考倒我 说散 你想很久了吧? 败给你的黑色幽默 说散 你想很久了吧? 我的认真败 - 不分开暴风圈来不及逃 我不能再想 我不能再想 我不 我不 我不能 爱情走的太快就像龙卷风 不能承受我已无处epoch 80, perplexity 1.012368, time 0.98 sec - 分开的玩笑 想通 却又再考倒我 说散 你想很久了吧? 败给你的黑色幽默 说散 你想很久了吧? 我的认真败 - 不分开爱玩笑 想通 却又再考倒我 说散 你想很久了吧? 败给你的黑色幽默 说散 你想很久了吧? 我的认真败epoch 120, perplexity 1.013130, time 0.91 sec - 分开的可爱女人 漂亮的让我面红的可爱女人 温柔的让我心疼的可爱女人 透明的让我感动的可爱女人 坏坏的让我 - 不分开不知不觉 你已经离开我 不知不觉 我跟了这节奏 后知后觉 又过了一个秋 后知后觉 我该好好生活 我该epoch 160, perplexity 1.008711, time 0.96 sec - 分开的可爱女人 漂亮的让我面红的可爱女人 温柔的让我心疼的可爱女人 透明的让我感动的可爱女人 坏坏的让我 - 不分开始打呼 管家是一只会说法语举止优雅的猪 吸血前会念约翰福音做为弥补 拥有一双蓝色眼睛的凯萨琳公主 专</code></pre><h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>** 长短期记忆long short-term memory **:<br>遗忘门:控制上一时间步的记忆细胞<br>输入门:控制当前时间步的输入<br>输出门:控制从记忆细胞到隐藏状态<br>记忆细胞：⼀种特殊的隐藏状态的信息的流动</p><p><img src="https://cdn.kesci.com/upload/image/q5jk2bnnej.png?imageView2/0/w/640/h/640" alt="Image Name"></p><p>$$<br>I_t = σ(X_tW_{xi} + H_{t−1}W_{hi} + b_i) \<br>F_t = σ(X_tW_{xf} + H_{t−1}W_{hf} + b_f)\<br>O_t = σ(X_tW_{xo} + H_{t−1}W_{ho} + b_o)\<br>\widetilde{C}<em>t = tanh(X_tW</em>{xc} + H_{t−1}W_{hc} + b_c)\<br>C_t = F_t ⊙C_{t−1} + I_t ⊙\widetilde{C}_t\<br>H_t = O_t⊙tanh(C_t)<br>$$</p><h3 id="初始化参数-1"><a href="#初始化参数-1" class="headerlink" title="初始化参数"></a>初始化参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">num_inputs, num_hiddens, num_outputs = vocab_size, <span class="number">256</span>, vocab_size</span><br><span class="line">print(<span class="string">'will use'</span>, device)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_one</span><span class="params">(shape)</span>:</span></span><br><span class="line">        ts = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=shape), device=device, dtype=torch.float32)</span><br><span class="line">        <span class="keyword">return</span> torch.nn.Parameter(ts, requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_three</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (_one((num_inputs, num_hiddens)),</span><br><span class="line">                _one((num_hiddens, num_hiddens)),</span><br><span class="line">                torch.nn.Parameter(torch.zeros(num_hiddens, device=device, dtype=torch.float32), requires_grad=<span class="literal">True</span>))</span><br><span class="line">    </span><br><span class="line">    W_xi, W_hi, b_i = _three()  <span class="comment"># 输入门参数</span></span><br><span class="line">    W_xf, W_hf, b_f = _three()  <span class="comment"># 遗忘门参数</span></span><br><span class="line">    W_xo, W_ho, b_o = _three()  <span class="comment"># 输出门参数</span></span><br><span class="line">    W_xc, W_hc, b_c = _three()  <span class="comment"># 候选记忆细胞参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = _one((num_hiddens, num_outputs))</span><br><span class="line">    b_q = torch.nn.Parameter(torch.zeros(num_outputs, device=device, dtype=torch.float32), requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> nn.ParameterList([W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc, b_c, W_hq, b_q])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_lstm_state</span><span class="params">(batch_size, num_hiddens, device)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device), </span><br><span class="line">            torch.zeros((batch_size, num_hiddens), device=device))</span><br></pre></td></tr></table></figure><pre><code>will use cpu</code></pre><h3 id="LSTM模型"><a href="#LSTM模型" class="headerlink" title="LSTM模型"></a>LSTM模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lstm</span><span class="params">(inputs, state, params)</span>:</span></span><br><span class="line">    [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc, b_c, W_hq, b_q] = params</span><br><span class="line">    (H, C) = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        I = torch.sigmoid(torch.matmul(X, W_xi) + torch.matmul(H, W_hi) + b_i)</span><br><span class="line">        F = torch.sigmoid(torch.matmul(X, W_xf) + torch.matmul(H, W_hf) + b_f)</span><br><span class="line">        O = torch.sigmoid(torch.matmul(X, W_xo) + torch.matmul(H, W_ho) + b_o)</span><br><span class="line">        C_tilda = torch.tanh(torch.matmul(X, W_xc) + torch.matmul(H, W_hc) + b_c)</span><br><span class="line">        C = F * C + I * C_tilda</span><br><span class="line">        H = O * C.tanh()</span><br><span class="line">        Y = torch.matmul(H, W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> outputs, (H, C)</span><br></pre></td></tr></table></figure><h3 id="训练模型-1"><a href="#训练模型-1" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, num_steps, batch_size, lr, clipping_theta = <span class="number">160</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">1e2</span>, <span class="number">1e-2</span></span><br><span class="line">pred_period, pred_len, prefixes = <span class="number">40</span>, <span class="number">50</span>, [<span class="string">'分开'</span>, <span class="string">'不分开'</span>]</span><br><span class="line"></span><br><span class="line">d2l.train_and_predict_rnn(lstm, get_params, init_lstm_state, num_hiddens,</span><br><span class="line">                          vocab_size, device, corpus_indices, idx_to_char,</span><br><span class="line">                          char_to_idx, <span class="literal">False</span>, num_epochs, num_steps, lr,</span><br><span class="line">                          clipping_theta, batch_size, pred_period, pred_len,</span><br><span class="line">                          prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 40, perplexity 211.056591, time 1.64 sec - 分开 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我 - 不分开 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我 我不的我epoch 80, perplexity 65.091712, time 1.53 sec - 分开 我想你这你 我不要 我不 我不要 我不要 我不要 我不要 我不要 我不要 我不要 我不要 我不要  - 不分开 我想你你想你 我想想这你 我不要 我不要 我不要 我不要 我不要 我不要 我不要 我不要 我不要 epoch 120, perplexity 17.263918, time 1.54 sec - 分开 我想你这生微 一天个对医药 我想这这样活 你天样 一直走 我想就好样 你不的节活 后知后觉 我该了 - 不分开 我想你的生笑 你天  又你的我面听 一发抖 快给我抬起头 有话去对医药 说知后觉 我想了这节活 后epoch 160, perplexity 3.906676, time 1.56 sec - 分开 你说的话不起 你学着碌的落 快什么 什什么 什么开有在留留 干什么 干什么 什么我有有片自 快使用 - 不分开我 想要你 你想我 想要再 我不再再了快 说说去对医药箱 说说  想想了久了着? 我不想想想你 你你</code></pre><h3 id="简洁实现-1"><a href="#简洁实现-1" class="headerlink" title="简洁实现"></a>简洁实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num_hiddens=<span class="number">256</span></span><br><span class="line">num_epochs, num_steps, batch_size, lr, clipping_theta = <span class="number">160</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">1e2</span>, <span class="number">1e-2</span></span><br><span class="line">pred_period, pred_len, prefixes = <span class="number">40</span>, <span class="number">50</span>, [<span class="string">'分开'</span>, <span class="string">'不分开'</span>]</span><br><span class="line"></span><br><span class="line">lr = <span class="number">1e-2</span> <span class="comment"># 注意调整学习率</span></span><br><span class="line">lstm_layer = nn.LSTM(input_size=vocab_size, hidden_size=num_hiddens)</span><br><span class="line">model = d2l.RNNModel(lstm_layer, vocab_size)</span><br><span class="line">d2l.train_and_predict_rnn_pytorch(model, num_hiddens, vocab_size, device,</span><br><span class="line">                                corpus_indices, idx_to_char, char_to_idx,</span><br><span class="line">                                num_epochs, num_steps, lr, clipping_theta,</span><br><span class="line">                                batch_size, pred_period, pred_len, prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 40, perplexity 1.028067, time 1.05 sec - 分开始我担 有AB血型的公老鼠 恍恍惚惚 是谁的脚步 银制茶壶 装蟑螂蜘蛛 辛辛苦苦 全家怕日出 白色蜡 - 不分开 我好好好生活 我叫你已经很久 别想躲 说你眼睛看着我 别发抖 快给我抬起头 有话去对医药箱说 别怪epoch 80, perplexity 1.021706, time 1.07 sec - 分开始我担 在小村外的溪边河口 默默的在等著我 家乡的爹娘早已苍老了轮廓 娘子我欠你太多 一壶好酒 再来 - 不分开 我叫我的爱  你叫我学习你把你当榜样  好多的假像 妈妈常说乖听你爸的话  你叫我怎么跟你像 不要epoch 120, perplexity 1.012656, time 1.02 sec - 分开始我攻 我的认真败给黑色幽默 走过了很多地方 我来到伊斯坦堡 就像是童话故事  有教堂有城堡 每天忙 - 不分开不多难道 快攻抢篮板球 得分都靠我 你拿着球不投 又不会掩护我 选你这种队友 瞎透了我 说你说 分数epoch 160, perplexity 1.010791, time 1.08 sec - 分开始我呼 在人有一切 真的可以 我想要将我的寂寞封闭 然后在这里 不限日期 然后将过去 慢慢温习 让我 - 不分开 我叫我学爱你看棒球 想这样没担忧 唱着歌 一直走 我想就这样牵着你的手不放开 爱可不可以简简单单没</code></pre><h1 id="深度循环神经网络"><a href="#深度循环神经网络" class="headerlink" title="深度循环神经网络"></a>深度循环神经网络</h1><p><img src="https://cdn.kesci.com/upload/image/q5jk3z1hvz.png?imageView2/0/w/320/h/320" alt="Image Name"></p><p>$$<br>\boldsymbol{H}<em>t^{(1)} = \phi(\boldsymbol{X}_t \boldsymbol{W}</em>{xh}^{(1)} + \boldsymbol{H}<em>{t-1}^{(1)} \boldsymbol{W}</em>{hh}^{(1)} + \boldsymbol{b}<em>h^{(1)})\<br>\boldsymbol{H}_t^{(\ell)} = \phi(\boldsymbol{H}_t^{(\ell-1)} \boldsymbol{W}</em>{xh}^{(\ell)} + \boldsymbol{H}<em>{t-1}^{(\ell)} \boldsymbol{W}</em>{hh}^{(\ell)} + \boldsymbol{b}<em>h^{(\ell)})\<br>\boldsymbol{O}_t = \boldsymbol{H}_t^{(L)} \boldsymbol{W}</em>{hq} + \boldsymbol{b}_q<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"../input/"</span>)</span><br><span class="line"><span class="keyword">import</span> d2l_jay9460 <span class="keyword">as</span> d2l</span><br><span class="line">device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line"></span><br><span class="line">(corpus_indices, char_to_idx, idx_to_char, vocab_size) = d2l.load_data_jay_lyrics()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">num_hiddens=<span class="number">256</span></span><br><span class="line">num_epochs, num_steps, batch_size, lr, clipping_theta = <span class="number">160</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">1e2</span>, <span class="number">1e-2</span></span><br><span class="line">pred_period, pred_len, prefixes = <span class="number">40</span>, <span class="number">50</span>, [<span class="string">'分开'</span>, <span class="string">'不分开'</span>]</span><br><span class="line"></span><br><span class="line">lr = <span class="number">1e-2</span> <span class="comment"># 注意调整学习率</span></span><br><span class="line"></span><br><span class="line">gru_layer = nn.LSTM(input_size=vocab_size, hidden_size=num_hiddens,num_layers=<span class="number">2</span>)</span><br><span class="line">model = d2l.RNNModel(gru_layer, vocab_size).to(device)</span><br><span class="line">d2l.train_and_predict_rnn_pytorch(model, num_hiddens, vocab_size, device,</span><br><span class="line">                                corpus_indices, idx_to_char, char_to_idx,</span><br><span class="line">                                num_epochs, num_steps, lr, clipping_theta,</span><br><span class="line">                                batch_size, pred_period, pred_len, prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 40, perplexity 1.779664, time 1.50 sec - 分开 我想多 一场默剧 你的完美主义 太彻底 让我连恨都难以下笔 将真心抽离写成日记 像是一场默剧 你的 - 不分开想要再想 我不多 我有多烦恼  没有你烦我有多烦恼多难熬  没有你烦我有多烦恼多难熬  没有你烦我有epoch 80, perplexity 1.017581, time 1.49 sec - 分开 我想一定是我听错弄错搞错 拜托 我想是你的脑袋有问题 随便说说 其实我早已经猜透看透不想多说 只是 - 不分开 那场悲剧 是你完美演出的一场戏 宁愿心碎哭泣 再狠狠忘记 你爱过我的证据 让晶莹的泪滴 闪烁成回忆epoch 120, perplexity 1.015036, time 1.50 sec - 分开 我有多难熬 我没有你烦 我有多烦恼  没有你烦我有多烦恼多难熬  穿过云层 我试著努力向你奔跑 爱 - 不分开 我有多难熬 我没有你烦 我有多烦恼  没有你烦我有多烦恼多难熬  穿过云层 我试著努力向你奔跑 爱epoch 160, perplexity 1.010326, time 1.51 sec - 分开 我有多难熬  没有你在 我有多难熬  没有你在我有多难熬多烦恼  没有你烦 我有多烦恼  没有你烦 - 不分开 我有多难熬 我跟了这节奏 后知后觉 又过了一个秋 后知后觉 我该好好生活 我该好好生活 不知不觉 </code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gru_layer = nn.LSTM(input_size=vocab_size, hidden_size=num_hiddens,num_layers=<span class="number">6</span>)</span><br><span class="line">model = d2l.RNNModel(gru_layer, vocab_size).to(device)</span><br><span class="line">d2l.train_and_predict_rnn_pytorch(model, num_hiddens, vocab_size, device,</span><br><span class="line">                                corpus_indices, idx_to_char, char_to_idx,</span><br><span class="line">                                num_epochs, num_steps, lr, clipping_theta,</span><br><span class="line">                                batch_size, pred_period, pred_len, prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 40, perplexity 275.835469, time 3.79 sec - 分开                                                   - 不分开                                                  epoch 80, perplexity 274.543441, time 3.88 sec - 分开                                                   - 不分开                                                  epoch 120, perplexity 274.099434, time 3.97 sec - 分开                                                   - 不分开                                                  epoch 160, perplexity 273.963849, time 4.07 sec - 分开                                                   - 不分开                                                  </code></pre><h1 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h1><p><img src="https://cdn.kesci.com/upload/image/q5j8hmgyrz.png?imageView2/0/w/320/h/320" alt="Image Name"></p><p>$$<br>\begin{aligned} \overrightarrow{\boldsymbol{H}}<em>t &amp;= \phi(\boldsymbol{X}_t \boldsymbol{W}</em>{xh}^{(f)} + \overrightarrow{\boldsymbol{H}}<em>{t-1} \boldsymbol{W}</em>{hh}^{(f)} + \boldsymbol{b}<em>h^{(f)})\<br>\overleftarrow{\boldsymbol{H}}_t &amp;= \phi(\boldsymbol{X}_t \boldsymbol{W}</em>{xh}^{(b)} + \overleftarrow{\boldsymbol{H}}<em>{t+1} \boldsymbol{W}</em>{hh}^{(b)} + \boldsymbol{b}<em>h^{(b)}) \end{aligned} $$<br>$$<br>\boldsymbol{H}_t=(\overrightarrow{\boldsymbol{H}}</em>{t}, \overleftarrow{\boldsymbol{H}}_t)<br>$$</p><p>$$<br>\boldsymbol{O}<em>t = \boldsymbol{H}_t \boldsymbol{W}</em>{hq} + \boldsymbol{b}_q<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">num_hiddens=<span class="number">128</span></span><br><span class="line">num_epochs, num_steps, batch_size, lr, clipping_theta = <span class="number">160</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">1e-2</span>, <span class="number">1e-2</span></span><br><span class="line">pred_period, pred_len, prefixes = <span class="number">40</span>, <span class="number">50</span>, [<span class="string">'分开'</span>, <span class="string">'不分开'</span>]</span><br><span class="line"></span><br><span class="line">lr = <span class="number">1e-2</span> <span class="comment"># 注意调整学习率</span></span><br><span class="line"></span><br><span class="line">gru_layer = nn.GRU(input_size=vocab_size, hidden_size=num_hiddens,bidirectional=<span class="literal">True</span>)</span><br><span class="line">model = d2l.RNNModel(gru_layer, vocab_size).to(device)</span><br><span class="line">d2l.train_and_predict_rnn_pytorch(model, num_hiddens, vocab_size, device,</span><br><span class="line">                                corpus_indices, idx_to_char, char_to_idx,</span><br><span class="line">                                num_epochs, num_steps, lr, clipping_theta,</span><br><span class="line">                                batch_size, pred_period, pred_len, prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 40, perplexity 1.001314, time 0.98 sec - 分开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开 - 不分开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开epoch 80, perplexity 1.000417, time 0.98 sec - 分开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开 - 不分开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开epoch 120, perplexity 1.000207, time 0.99 sec - 分开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开 - 不分开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开epoch 160, perplexity 1.000124, time 0.94 sec - 分开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开始开 - 不分开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开不开</code></pre><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="GRU" scheme="http://yoursite.com/tags/GRU/"/>
    
      <category term="LSTM" scheme="http://yoursite.com/tags/LSTM/"/>
    
      <category term="deep RNN" scheme="http://yoursite.com/tags/deep-RNN/"/>
    
      <category term="Bi-directional RNN" scheme="http://yoursite.com/tags/Bi-directional-RNN/"/>
    
      <category term="深度学习实战" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
  </entry>
  
  <entry>
    <title>Task1.8 梯度消失、梯度爆炸以及Kaggle房价预测</title>
    <link href="http://yoursite.com/2020/02/19/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E3%80%81%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/"/>
    <id>http://yoursite.com/2020/02/19/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E3%80%81%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/</id>
    <published>2020-02-19T13:00:53.767Z</published>
    <updated>2020-02-19T13:04:40.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="梯度消失、梯度爆炸以及Kaggle房价预测"><a href="#梯度消失、梯度爆炸以及Kaggle房价预测" class="headerlink" title="梯度消失、梯度爆炸以及Kaggle房价预测"></a>梯度消失、梯度爆炸以及Kaggle房价预测</h1><ol><li>梯度消失和梯度爆炸</li><li>考虑到环境因素的其他问题</li><li>Kaggle房价预测</li></ol><h1 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h1><p>深度模型有关数值稳定性的典型问题是消失（vanishing）和爆炸（explosion）。</p><p><strong>当神经网络的层数较多时，模型的数值稳定性容易变差。</strong></p><p>假设一个层数为$L$的多层感知机的第$l$层$\boldsymbol{H}^{(l)}$的权重参数为$\boldsymbol{W}^{(l)}$，输出层$\boldsymbol{H}^{(L)}$的权重参数为$\boldsymbol{W}^{(L)}$。为了便于讨论，不考虑偏差参数，且设所有隐藏层的激活函数为恒等映射（identity mapping）$\phi(x) = x$。给定输入$\boldsymbol{X}$，多层感知机的第$l$层的输出$\boldsymbol{H}^{(l)} = \boldsymbol{X} \boldsymbol{W}^{(1)} \boldsymbol{W}^{(2)} \ldots \boldsymbol{W}^{(l)}$。此时，如果层数$l$较大，$\boldsymbol{H}^{(l)}$的计算可能会出现衰减或爆炸。举个例子，假设输入和所有层的权重参数都是标量，如权重参数为0.2和5，多层感知机的第30层输出为输入$\boldsymbol{X}$分别与$0.2^{30} \approx 1 \times 10^{-21}$（消失）和$5^{30} \approx 9 \times 10^{20}$（爆炸）的乘积。当层数较多时，梯度的计算也容易出现消失或爆炸。</p><h1 id="随机初始化模型参数"><a href="#随机初始化模型参数" class="headerlink" title="随机初始化模型参数"></a>随机初始化模型参数</h1><p>在神经网络中，通常需要随机初始化模型参数。下面我们来解释这样做的原因。</p><p>回顾多层感知机一节描述的多层感知机。为了方便解释，假设输出层只保留一个输出单元$o_1$（删去$o_2$和$o_3$以及指向它们的箭头），且隐藏层使用相同的激活函数。如果将每个隐藏单元的参数都初始化为相等的值，那么在正向传播时每个隐藏单元将根据相同的输入计算出相同的值，并传递至输出层。在反向传播中，每个隐藏单元的参数梯度值相等。因此，这些参数在使用基于梯度的优化算法迭代后值依然相等。之后的迭代也是如此。在这种情况下，无论隐藏单元有多少，隐藏层本质上只有1个隐藏单元在发挥作用。因此，正如在前面的实验中所做的那样，我们通常将神经网络的模型参数，特别是权重参数，进行随机初始化。</p><p><img src="https://cdn.kesci.com/upload/image/q5jg76kloy.png?imageView2/0/w/960/h/960" alt="Image Name"></p><h3 id="PyTorch的默认随机初始化"><a href="#PyTorch的默认随机初始化" class="headerlink" title="PyTorch的默认随机初始化"></a>PyTorch的默认随机初始化</h3><p>随机初始化模型参数的方法有很多。在线性回归的简洁实现中，我们使用<code>torch.nn.init.normal_()</code>使模型<code>net</code>的权重参数采用正态分布的随机初始化方式。不过，PyTorch中<code>nn.Module</code>的模块参数都采取了较为合理的初始化策略（不同类型的layer具体采样的哪一种初始化方法的可参考<a href="https://github.com/pytorch/pytorch/tree/master/torch/nn/modules" target="_blank" rel="noopener">源代码</a>），因此一般不用我们考虑。</p><h3 id="Xavier随机初始化"><a href="#Xavier随机初始化" class="headerlink" title="Xavier随机初始化"></a>Xavier随机初始化</h3><p>还有一种比较常用的随机初始化方法叫作Xavier随机初始化。<br>假设某全连接层的输入个数为$a$，输出个数为$b$，Xavier随机初始化将使该层中权重参数的每个元素都随机采样于均匀分布</p><p>$$<br>U\left(-\sqrt{\frac{6}{a+b}}, \sqrt{\frac{6}{a+b}}\right).<br>$$</p><p>它的设计主要考虑到，模型参数初始化后，每层输出的方差不该受该层输入个数影响，且每层梯度的方差也不该受该层输出个数影响。</p><h1 id="考虑环境因素"><a href="#考虑环境因素" class="headerlink" title="考虑环境因素"></a>考虑环境因素</h1><h2 id="协变量偏移"><a href="#协变量偏移" class="headerlink" title="协变量偏移"></a>协变量偏移</h2><p>这里我们假设，虽然输入的分布可能随时间而改变，但是标记函数，即条件分布P（y∣x）不会改变。虽然这个问题容易理解，但在实践中也容易忽视。</p><p>想想区分猫和狗的一个例子。我们的训练数据使用的是猫和狗的真实的照片，但是在测试时，我们被要求对猫和狗的卡通图片进行分类。</p><table><thead><tr><th align="center">cat</th><th align="center">cat</th><th align="center">dog</th><th align="center">dog</th></tr></thead><tbody><tr><td align="center"><img src="https://cdn.kesci.com/upload/image/q5jg8j72fl.jpg?imageView2/0/w/200/h/200" alt="Image Name"></td><td align="center"><img src="https://cdn.kesci.com/upload/image/q5jg993za3.jpg?imageView2/0/w/200/h/200" alt="Image Name"></td><td align="center"><img src="https://cdn.kesci.com/upload/image/q5jg9tqs4s.jpg?imageView2/0/w/200/h/200" alt="Image Name"></td><td align="center"><img src="https://cdn.kesci.com/upload/image/q5jga6mnsk.jpg?imageView2/0/w/200/h/200" alt="Image Name"></td></tr></tbody></table><p>测试数据：</p><table><thead><tr><th align="center">cat</th><th align="center">cat</th><th align="center">dog</th><th align="center">dog</th></tr></thead><tbody><tr><td align="center"><img src="https://cdn.kesci.com/upload/image/q5jgat5lsd.png?imageView2/0/w/200/h/200" alt="Image Name"></td><td align="center"><img src="https://cdn.kesci.com/upload/image/q5jgbaoij8.png?imageView2/0/w/200/h/200" alt="Image Name"></td><td align="center"><img src="https://cdn.kesci.com/upload/image/q5jgbswvbb.png?imageView2/0/w/200/h/200" alt="Image Name"></td><td align="center"><img src="https://cdn.kesci.com/upload/image/q5jgc5j7zv.png?imageView2/0/w/200/h/200" alt="Image Name"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>显然，这不太可能奏效。训练集由照片组成，而测试集只包含卡通。在一个看起来与测试集有着本质不同的数据集上进行训练，而不考虑如何适应新的情况，这是不是一个好主意。不幸的是，这是一个非常常见的陷阱。</p><p>统计学家称这种协变量变化是因为问题的根源在于特征分布的变化（即协变量的变化）。数学上，我们可以说P（x）改变了，但P（y∣x）保持不变。尽管它的有用性并不局限于此，当我们认为x导致y时，协变量移位通常是正确的假设。</p><h2 id="标签偏移"><a href="#标签偏移" class="headerlink" title="标签偏移"></a>标签偏移</h2><p>当我们认为导致偏移的是标签P（y）上的边缘分布的变化，但类条件分布是不变的P（x∣y）时，就会出现相反的问题。当我们认为y导致x时，标签偏移是一个合理的假设。例如，通常我们希望根据其表现来预测诊断结果。在这种情况下，我们认为诊断引起的表现，即疾病引起的症状。有时标签偏移和协变量移位假设可以同时成立。例如，当真正的标签函数是确定的和不变的，那么协变量偏移将始终保持，包括如果标签偏移也保持。有趣的是，当我们期望标签偏移和协变量偏移保持时，使用来自标签偏移假设的方法通常是有利的。这是因为这些方法倾向于操作看起来像标签的对象，这（在深度学习中）与处理看起来像输入的对象（在深度学习中）相比相对容易一些。</p><p>病因（要预测的诊断结果）导致 症状（观察到的结果）。</p><p>训练数据集，数据很少只包含流感p(y)的样本。</p><p>而测试数据集有流感p(y)和流感q(y)，其中不变的是流感症状p(x|y)。</p><h2 id="概念偏移"><a href="#概念偏移" class="headerlink" title="概念偏移"></a>概念偏移</h2><p>另一个相关的问题出现在概念转换中，即标签本身的定义发生变化的情况。这听起来很奇怪，毕竟猫就是猫。的确，猫的定义可能不会改变，但我们能不能对软饮料也这么说呢？事实证明，如果我们周游美国，按地理位置转移数据来源，我们会发现，即使是如图所示的这个简单术语的定义也会发生相当大的概念转变。</p><p><img src="https://cdn.kesci.com/upload/image/q5jgd81pl3.png?imageView2/0/w/640/h/640" alt="Image Name"></p><p>$$<br>美国软饮料名称的概念转变<br>$$<br>如果我们要建立一个机器翻译系统，分布P（y∣x）可能因我们的位置而异。这个问题很难发现。另一个可取之处是P（y∣x）通常只是逐渐变化。</p><h1 id="Kaggle-房价预测实战"><a href="#Kaggle-房价预测实战" class="headerlink" title="Kaggle 房价预测实战"></a>Kaggle 房价预测实战</h1><p>作为深度学习基础篇章的总结，我们将对本章内容学以致用。下面，让我们动手实战一个Kaggle比赛：房价预测。本节将提供未经调优的数据的预处理、模型的设计和超参数的选择。我们希望读者通过动手操作、仔细观察实验现象、认真分析实验结果并不断调整方法，得到令自己满意的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line">print(torch.__version__)</span><br><span class="line">torch.set_default_tensor_type(torch.FloatTensor)</span><br></pre></td></tr></table></figure><pre><code>1.3.0</code></pre><h2 id="获取和读取数据集"><a href="#获取和读取数据集" class="headerlink" title="获取和读取数据集"></a>获取和读取数据集</h2><p>比赛数据分为训练数据集和测试数据集。两个数据集都包括每栋房子的特征，如街道类型、建造年份、房顶类型、地下室状况等特征值。这些特征值有连续的数字、离散的标签甚至是缺失值“na”。只有训练数据集包括了每栋房子的价格，也就是标签。我们可以访问比赛网页，点击“Data”标签，并下载这些数据集。</p><p>我们将通过<code>pandas</code>库读入并处理数据。在导入本节需要的包前请确保已安装<code>pandas</code>库。<br>假设解压后的数据位于<code>/home/kesci/input/houseprices2807/</code>目录，它包括两个csv文件。下面使用<code>pandas</code>读取这两个文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_data = pd.read_csv(<span class="string">"/home/kesci/input/houseprices2807/house-prices-advanced-regression-techniques/test.csv"</span>)</span><br><span class="line">train_data = pd.read_csv(<span class="string">"/home/kesci/input/houseprices2807/house-prices-advanced-regression-techniques/train.csv"</span>)</span><br></pre></td></tr></table></figure><p>训练数据集包括1460个样本、80个特征和1个标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data.shape</span><br></pre></td></tr></table></figure><pre><code>(1460, 81)</code></pre><p>测试数据集包括1459个样本和80个特征。我们需要将测试数据集中每个样本的标签预测出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_data.shape</span><br></pre></td></tr></table></figure><pre><code>(1459, 80)</code></pre><p>让我们来查看前4个样本的前4个特征、后2个特征和标签（SalePrice）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data.iloc[<span class="number">0</span>:<span class="number">4</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>]]</span><br></pre></td></tr></table></figure><div><style scoped>.dataframe tbody tr th:only-of-type{vertical-align:middle}<pre><code>.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</code></pre><p></style><p></p><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Id</th><th>MSSubClass</th><th>MSZoning</th><th>LotFrontage</th><th>SaleType</th><th>SaleCondition</th><th>SalePrice</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>60</td><td>RL</td><td>65.0</td><td>WD</td><td>Normal</td><td>208500</td></tr><tr><td>1</td><td>2</td><td>20</td><td>RL</td><td>80.0</td><td>WD</td><td>Normal</td><td>181500</td></tr><tr><td>2</td><td>3</td><td>60</td><td>RL</td><td>68.0</td><td>WD</td><td>Normal</td><td>223500</td></tr><tr><td>3</td><td>4</td><td>70</td><td>RL</td><td>60.0</td><td>WD</td><td>Abnorml</td><td>140000</td></tr></tbody></table></div><p>可以看到第一个特征是Id，它能帮助模型记住每个训练样本，但难以推广到测试样本，所以我们不使用它来训练。我们将所有的训练数据和测试数据的79个特征按样本连结。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_features = pd.concat((train_data.iloc[:, <span class="number">1</span>:<span class="number">-1</span>], test_data.iloc[:, <span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><h2 id="预处理数据"><a href="#预处理数据" class="headerlink" title="预处理数据"></a>预处理数据</h2><p>我们对连续数值的特征做标准化（standardization）：设该特征在整个数据集上的均值为$\mu$，标准差为$\sigma$。那么，我们可以将该特征的每个值先减去$\mu$再除以$\sigma$得到标准化后的每个特征值。对于缺失的特征值，我们将其替换成该特征的均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numeric_features = all_features.dtypes[all_features.dtypes != <span class="string">'object'</span>].index</span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].apply(</span><br><span class="line">    <span class="keyword">lambda</span> x: (x - x.mean()) / (x.std()))</span><br><span class="line"><span class="comment"># 标准化后，每个数值特征的均值变为0，所以可以直接用0来替换缺失值</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>接下来将离散数值转成指示特征。举个例子，假设特征MSZoning里面有两个不同的离散值RL和RM，那么这一步转换将去掉MSZoning特征，并新加两个特征MSZoning_RL和MSZoning_RM，其值为0或1。如果一个样本原来在MSZoning里的值为RL，那么有MSZoning_RL=1且MSZoning_RM=0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy_na=True将缺失值也当作合法的特征值并为其创建指示特征</span></span><br><span class="line">all_features = pd.get_dummies(all_features, dummy_na=<span class="literal">True</span>)</span><br><span class="line">all_features.shape</span><br></pre></td></tr></table></figure><pre><code>(2919, 331)</code></pre><p>可以看到这一步转换将特征数从79增加到了331。</p><p>最后，通过<code>values</code>属性得到NumPy格式的数据，并转成<code>Tensor</code>方便后面的训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n_train = train_data.shape[<span class="number">0</span>]</span><br><span class="line">train_features = torch.tensor(all_features[:n_train].values, dtype=torch.float)</span><br><span class="line">test_features = torch.tensor(all_features[n_train:].values, dtype=torch.float)</span><br><span class="line">train_labels = torch.tensor(train_data.SalePrice.values, dtype=torch.float).view(<span class="number">-1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loss = torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span><span class="params">(feature_num)</span>:</span></span><br><span class="line">    net = nn.Linear(feature_num, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> net.parameters():</span><br><span class="line">        nn.init.normal_(param, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><p>下面定义比赛用来评价模型的对数均方根误差。给定预测值$\hat y_1, \ldots, \hat y_n$和对应的真实标签$y_1,\ldots, y_n$，它的定义为</p><p>$$<br>\sqrt{\frac{1}{n}\sum_{i=1}^n\left(\log(y_i)-\log(\hat y_i)\right)^2}.<br>$$</p><p>对数均方根误差的实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_rmse</span><span class="params">(net, features, labels)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="comment"># 将小于1的值设成1，使得取对数时数值更稳定</span></span><br><span class="line">        clipped_preds = torch.max(net(features), torch.tensor(<span class="number">1.0</span>))</span><br><span class="line">        rmse = torch.sqrt(<span class="number">2</span> * loss(clipped_preds.log(), labels.log()).mean())</span><br><span class="line">    <span class="keyword">return</span> rmse.item()</span><br></pre></td></tr></table></figure><p>下面的训练函数跟本章中前几节的不同在于使用了Adam优化算法。相对之前使用的小批量随机梯度下降，它对学习率相对不那么敏感。我们将在之后的“优化算法”一章里详细介绍它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(net, train_features, train_labels, test_features, test_labels,</span></span></span><br><span class="line"><span class="function"><span class="params">          num_epochs, learning_rate, weight_decay, batch_size)</span>:</span></span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    dataset = torch.utils.data.TensorDataset(train_features, train_labels)</span><br><span class="line">    train_iter = torch.utils.data.DataLoader(dataset, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 这里使用了Adam优化算法</span></span><br><span class="line">    optimizer = torch.optim.Adam(params=net.parameters(), lr=learning_rate, weight_decay=weight_decay) </span><br><span class="line">    net = net.float()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            l = loss(net(X.float()), y.float())</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        train_ls.append(log_rmse(net, train_features, train_labels))</span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(log_rmse(net, test_features, test_labels))</span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br></pre></td></tr></table></figure><h2 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h2><p>我们在模型选择、欠拟合和过拟合中介绍了$K$折交叉验证。它将被用来选择模型设计并调节超参数。下面实现了一个函数，它返回第<code>i</code>折交叉验证时所需要的训练和验证数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_k_fold_data</span><span class="params">(k, i, X, y)</span>:</span></span><br><span class="line">    <span class="comment"># 返回第i折交叉验证时所需要的训练和验证数据</span></span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X.shape[<span class="number">0</span>] // k</span><br><span class="line">    X_train, y_train = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">        idx = slice(j * fold_size, (j + <span class="number">1</span>) * fold_size)</span><br><span class="line">        X_part, y_part = X[idx, :], y[idx]</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            X_valid, y_valid = X_part, y_part</span><br><span class="line">        <span class="keyword">elif</span> X_train <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            X_train, y_train = X_part, y_part</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = torch.cat((X_train, X_part), dim=<span class="number">0</span>)</span><br><span class="line">            y_train = torch.cat((y_train, y_part), dim=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, y_train, X_valid, y_valid</span><br></pre></td></tr></table></figure><p>在$K$折交叉验证中我们训练$K$次并返回训练和验证的平均误差</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_fold</span><span class="params">(k, X_train, y_train, num_epochs,</span></span></span><br><span class="line"><span class="function"><span class="params">           learning_rate, weight_decay, batch_size)</span>:</span></span><br><span class="line">    train_l_sum, valid_l_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        data = get_k_fold_data(k, i, X_train, y_train)</span><br><span class="line">        net = get_net(X_train.shape[<span class="number">1</span>])</span><br><span class="line">        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate,</span><br><span class="line">                                   weight_decay, batch_size)</span><br><span class="line">        train_l_sum += train_ls[<span class="number">-1</span>]</span><br><span class="line">        valid_l_sum += valid_ls[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            d2l.semilogy(range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, <span class="string">'epochs'</span>, <span class="string">'rmse'</span>,</span><br><span class="line">                         range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), valid_ls,</span><br><span class="line">                         [<span class="string">'train'</span>, <span class="string">'valid'</span>])</span><br><span class="line">        print(<span class="string">'fold %d, train rmse %f, valid rmse %f'</span> % (i, train_ls[<span class="number">-1</span>], valid_ls[<span class="number">-1</span>]))</span><br><span class="line">    <span class="keyword">return</span> train_l_sum / k, valid_l_sum / k</span><br></pre></td></tr></table></figure><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>我们使用一组未经调优的超参数并计算交叉验证误差。可以改动这些超参数来尽可能减小平均测试误差。<br>有时候你会发现一组参数的训练误差可以达到很低，但是在$K$折交叉验证上的误差可能反而较高。这种现象很可能是由过拟合造成的。因此，当训练误差降低时，我们要观察$K$折交叉验证上的误差是否也相应降低。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k, num_epochs, lr, weight_decay, batch_size = <span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">64</span></span><br><span class="line">train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr, weight_decay, batch_size)</span><br><span class="line">print(<span class="string">'%d-fold validation: avg train rmse %f, avg valid rmse %f'</span> % (k, train_l, valid_l))</span><br></pre></td></tr></table></figure><pre><code>fold 0, train rmse 0.241183, valid rmse 0.222194fold 1, train rmse 0.229328, valid rmse 0.269645fold 2, train rmse 0.232232, valid rmse 0.238698fold 3, train rmse 0.238247, valid rmse 0.218718fold 4, train rmse 0.230709, valid rmse 0.2586185-fold validation: avg train rmse 0.234340, avg valid rmse 0.241574</code></pre><img src="https://cdn.kesci.com/rt_upload/989B1E6DC2F046A6899429AC97B29EC0/q5y4ewsu39.svg"><h1 id="预测并在Kaggle中提交结果"><a href="#预测并在Kaggle中提交结果" class="headerlink" title="预测并在Kaggle中提交结果"></a>预测并在Kaggle中提交结果</h1><p>下面定义预测函数。在预测之前，我们会使用完整的训练数据集来重新训练模型，并将预测结果存成提交所需要的格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_and_pred</span><span class="params">(train_features, test_features, train_labels, test_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                   num_epochs, lr, weight_decay, batch_size)</span>:</span></span><br><span class="line">    net = get_net(train_features.shape[<span class="number">1</span>])</span><br><span class="line">    train_ls, _ = train(net, train_features, train_labels, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line">                        num_epochs, lr, weight_decay, batch_size)</span><br><span class="line">    d2l.semilogy(range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, <span class="string">'epochs'</span>, <span class="string">'rmse'</span>)</span><br><span class="line">    print(<span class="string">'train rmse %f'</span> % train_ls[<span class="number">-1</span>])</span><br><span class="line">    preds = net(test_features).detach().numpy()</span><br><span class="line">    test_data[<span class="string">'SalePrice'</span>] = pd.Series(preds.reshape(<span class="number">1</span>, <span class="number">-1</span>)[<span class="number">0</span>])</span><br><span class="line">    submission = pd.concat([test_data[<span class="string">'Id'</span>], test_data[<span class="string">'SalePrice'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">    submission.to_csv(<span class="string">'./submission.csv'</span>, index=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># sample_submission_data = pd.read_csv("../input/house-prices-advanced-regression-techniques/sample_submission.csv")</span></span><br></pre></td></tr></table></figure><p>设计好模型并调好超参数之后，下一步就是对测试数据集上的房屋样本做价格预测。如果我们得到与交叉验证时差不多的训练误差，那么这个结果很可能是理想的，可以在Kaggle上提交结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size)</span><br></pre></td></tr></table></figure><pre><code>train rmse 0.229658</code></pre><img src="https://cdn.kesci.com/rt_upload/9F99F864AB2946B6A6AD66AADBD44F2D/q5y4f98p9.svg"><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="深度学习实战" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
      <category term="梯度消失" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1/"/>
    
      <category term="梯度爆炸" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/"/>
    
      <category term="Xavier随机初始化" scheme="http://yoursite.com/tags/Xavier%E9%9A%8F%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
      <category term="协变量偏移" scheme="http://yoursite.com/tags/%E5%8D%8F%E5%8F%98%E9%87%8F%E5%81%8F%E7%A7%BB/"/>
    
      <category term="标签偏移" scheme="http://yoursite.com/tags/%E6%A0%87%E7%AD%BE%E5%81%8F%E7%A7%BB/"/>
    
      <category term="概念偏移" scheme="http://yoursite.com/tags/%E6%A6%82%E5%BF%B5%E5%81%8F%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>Task1.7 过拟合、欠拟合及其解决方案</title>
    <link href="http://yoursite.com/2020/02/19/%E8%BF%87%E6%8B%9F%E5%90%88%E6%AC%A0%E6%8B%9F%E5%90%88%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2020/02/19/%E8%BF%87%E6%8B%9F%E5%90%88%E6%AC%A0%E6%8B%9F%E5%90%88%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-02-19T10:37:07.367Z</published>
    <updated>2020-02-19T10:36:44.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="过拟合、欠拟合及其解决方案"><a href="#过拟合、欠拟合及其解决方案" class="headerlink" title="过拟合、欠拟合及其解决方案"></a>过拟合、欠拟合及其解决方案</h1><ol><li>过拟合、欠拟合的概念</li><li>权重衰减</li><li>丢弃法</li></ol><h1 id="模型选择、过拟合和欠拟合"><a href="#模型选择、过拟合和欠拟合" class="headerlink" title="模型选择、过拟合和欠拟合"></a>模型选择、过拟合和欠拟合</h1><h2 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="训练误差和泛化误差"></a>训练误差和泛化误差</h2><p>在解释上述现象之前，我们需要区分训练误差（training error）和泛化误差（generalization error）。通俗来讲，前者指模型在训练数据集上表现出的误差，后者指模型在任意一个测试数据样本上表现出的误差的期望，并常常通过测试数据集上的误差来近似。计算训练误差和泛化误差可以使用之前介绍过的损失函数，例如线性回归用到的平方损失函数和softmax回归用到的交叉熵损失函数。</p><p>机器学习模型应关注降低泛化误差。</p><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><h3 id="验证数据集"><a href="#验证数据集" class="headerlink" title="验证数据集"></a>验证数据集</h3><p>从严格意义上讲，测试集只能在所有超参数和模型参数选定后使用一次。不可以使用测试数据选择模型，如调参。由于无法从训练误差估计泛化误差，因此也不应只依赖训练数据选择模型。鉴于此，我们可以预留一部分在训练数据集和测试数据集以外的数据来进行模型选择。这部分数据被称为验证数据集，简称验证集（validation set）。例如，我们可以从给定的训练集中随机选取一小部分作为验证集，而将剩余部分作为真正的训练集。</p><h3 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h3><p>由于验证数据集不参与模型训练，当训练数据不够用时，预留大量的验证数据显得太奢侈。一种改善的方法是K折交叉验证（K-fold cross-validation）。在K折交叉验证中，我们把原始训练数据集分割成K个不重合的子数据集，然后我们做K次模型训练和验证。每一次，我们使用一个子数据集验证模型，并使用其他K-1个子数据集来训练模型。在这K次训练和验证中，每次用来验证模型的子数据集都不同。最后，我们对这K次训练误差和验证误差分别求平均。</p><h2 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h2><p>接下来，我们将探究模型训练中经常出现的两类典型问题：</p><ul><li>一类是模型无法得到较低的训练误差，我们将这一现象称作欠拟合（underfitting）；</li><li>另一类是模型的训练误差远小于它在测试数据集上的误差，我们称该现象为过拟合（overfitting）。<br>在实践中，我们要尽可能同时应对欠拟合和过拟合。虽然有很多因素可能导致这两种拟合问题，在这里我们重点讨论两个因素：模型复杂度和训练数据集大小。</li></ul><h3 id="模型复杂度"><a href="#模型复杂度" class="headerlink" title="模型复杂度"></a>模型复杂度</h3><p>为了解释模型复杂度，我们以多项式函数拟合为例。给定一个由标量数据特征$x$和对应的标量标签$y$组成的训练数据集，多项式函数拟合的目标是找一个$K$阶多项式函数</p><p>$$<br>\hat{y} = b + \sum_{k=1}^K x^k w_k<br>$$</p><p>来近似 $y$。在上式中，$w_k$是模型的权重参数，$b$是偏差参数。与线性回归相同，多项式函数拟合也使用平方损失函数。特别地，一阶多项式函数拟合又叫线性函数拟合。</p><p>给定训练数据集，模型复杂度和误差之间的关系：</p><p><img src="https://cdn.kesci.com/upload/image/q5jc27wxoj.png?imageView2/0/w/960/h/960" alt="Image Name"></p><h3 id="训练数据集大小"><a href="#训练数据集大小" class="headerlink" title="训练数据集大小"></a>训练数据集大小</h3><p>影响欠拟合和过拟合的另一个重要因素是训练数据集的大小。一般来说，如果训练数据集中样本数过少，特别是比模型参数数量（按元素计）更少时，过拟合更容易发生。此外，泛化误差不会随训练数据集里样本数量增加而增大。因此，在计算资源允许的范围之内，我们通常希望训练数据集大一些，特别是在模型复杂度较高时，例如层数较多的深度学习模型。</p><h1 id="多项式函数拟合实验"><a href="#多项式函数拟合实验" class="headerlink" title="多项式函数拟合实验"></a>多项式函数拟合实验</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.3.0</code></pre><h2 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n_train, n_test, true_w, true_b = <span class="number">100</span>, <span class="number">100</span>, [<span class="number">1.2</span>, <span class="number">-3.4</span>, <span class="number">5.6</span>], <span class="number">5</span> <span class="comment"># n_train,n_test: 训练和测试样本数</span></span><br><span class="line">features = torch.randn((n_train + n_test, <span class="number">1</span>))</span><br><span class="line">poly_features = torch.cat((features, torch.pow(features, <span class="number">2</span>), torch.pow(features, <span class="number">3</span>)), <span class="number">1</span>) <span class="comment"># 聚合特征 </span></span><br><span class="line">labels = (true_w[<span class="number">0</span>] * poly_features[:, <span class="number">0</span>] + true_w[<span class="number">1</span>] * poly_features[:, <span class="number">1</span>]</span><br><span class="line">          + true_w[<span class="number">2</span>] * poly_features[:, <span class="number">2</span>] + true_b)</span><br><span class="line">labels += torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=labels.size()), dtype=torch.float)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features[:<span class="number">2</span>], poly_features[:<span class="number">2</span>], labels[:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><pre><code>(tensor([[-1.4290],         [-0.7796]]), tensor([[-1.4290,  2.0420, -2.9180],         [-0.7796,  0.6078, -0.4738]]), tensor([-19.9945,  -0.6596]))</code></pre><h2 id="定义、训练和测试模型"><a href="#定义、训练和测试模型" class="headerlink" title="定义、训练和测试模型"></a>定义、训练和测试模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">semilogy</span><span class="params">(x_vals, y_vals, x_label, y_label, x2_vals=None, y2_vals=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             legend=None, figsize=<span class="params">(<span class="number">3.5</span>, <span class="number">2.5</span>)</span>)</span>:</span></span><br><span class="line">    <span class="comment"># d2l.set_figsize(figsize) </span></span><br><span class="line">    <span class="comment"># 绘图观察训练误差和泛化误差</span></span><br><span class="line">    d2l.plt.xlabel(x_label)</span><br><span class="line">    d2l.plt.ylabel(y_label)</span><br><span class="line">    d2l.plt.semilogy(x_vals, y_vals)</span><br><span class="line">    <span class="keyword">if</span> x2_vals <span class="keyword">and</span> y2_vals:</span><br><span class="line">        d2l.plt.semilogy(x2_vals, y2_vals, linestyle=<span class="string">':'</span>)</span><br><span class="line">        d2l.plt.legend(legend)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, loss = <span class="number">100</span>, torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_and_plot</span><span class="params">(train_features, test_features, train_labels, test_labels)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化网络模型 </span></span><br><span class="line">    net = torch.nn.Linear(train_features.shape[<span class="number">-1</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 通过Linear文档可知，pytorch已经将参数初始化了，所以我们这里就不手动初始化了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置批量大小</span></span><br><span class="line">    batch_size = min(<span class="number">10</span>, train_labels.shape[<span class="number">0</span>])    </span><br><span class="line">    dataset = torch.utils.data.TensorDataset(train_features, train_labels)      <span class="comment"># 设置数据集</span></span><br><span class="line">    train_iter = torch.utils.data.DataLoader(dataset, batch_size, shuffle=<span class="literal">True</span>) <span class="comment"># 设置获取数据方式</span></span><br><span class="line">    </span><br><span class="line">    optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.01</span>)                      <span class="comment"># 设置优化函数，使用的是随机梯度下降优化</span></span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:                                                 <span class="comment"># 取一个批量的数据</span></span><br><span class="line">            l = loss(net(X), y.view(<span class="number">-1</span>, <span class="number">1</span>))                                     <span class="comment"># 输入到网络中计算输出，并和标签比较求得损失函数</span></span><br><span class="line">            optimizer.zero_grad()                                               <span class="comment"># 梯度清零，防止梯度累加干扰优化</span></span><br><span class="line">            l.backward()                                                        <span class="comment"># 求梯度</span></span><br><span class="line">            optimizer.step()                                                    <span class="comment"># 迭代优化函数，进行参数优化</span></span><br><span class="line">        train_labels = train_labels.view(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        test_labels = test_labels.view(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        train_ls.append(loss(net(train_features), train_labels).item())         <span class="comment"># 将训练损失保存到train_ls中</span></span><br><span class="line">        test_ls.append(loss(net(test_features), test_labels).item())            <span class="comment"># 将测试损失保存到test_ls中</span></span><br><span class="line">    print(<span class="string">'final epoch: train loss'</span>, train_ls[<span class="number">-1</span>], <span class="string">'test loss'</span>, test_ls[<span class="number">-1</span>])    </span><br><span class="line">    semilogy(range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, <span class="string">'epochs'</span>, <span class="string">'loss'</span>,</span><br><span class="line">             range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), test_ls, [<span class="string">'train'</span>, <span class="string">'test'</span>])</span><br><span class="line">    print(<span class="string">'weight:'</span>, net.weight.data,</span><br><span class="line">          <span class="string">'\nbias:'</span>, net.bias.data)</span><br></pre></td></tr></table></figure><h2 id="三阶多项式函数拟合（正常）"><a href="#三阶多项式函数拟合（正常）" class="headerlink" title="三阶多项式函数拟合（正常）"></a>三阶多项式函数拟合（正常）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit_and_plot(poly_features[:n_train, :], poly_features[n_train:, :], labels[:n_train], labels[n_train:])</span><br></pre></td></tr></table></figure><pre><code>final epoch: train loss 8.688789239386097e-05 test loss 0.00013709806080441922weight: tensor([[ 1.2096, -3.3997,  5.5957]]) bias: tensor([4.9997])</code></pre><img src="https://cdn.kesci.com/rt_upload/CD685B472B744329A1CFC47C9F0B5E89/q5y1wa66hw.png"><h2 id="线性函数拟合（欠拟合）"><a href="#线性函数拟合（欠拟合）" class="headerlink" title="线性函数拟合（欠拟合）"></a>线性函数拟合（欠拟合）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit_and_plot(features[:n_train, :], features[n_train:, :], labels[:n_train], labels[n_train:])</span><br></pre></td></tr></table></figure><pre><code>final epoch: train loss 48.80396270751953 test loss 64.74662780761719weight: tensor([[12.6501]]) bias: tensor([1.9682])</code></pre><img src="https://cdn.kesci.com/rt_upload/33AD626DA0B94DB7A28D47697312B45D/q5y1wxpq5v.png"><h2 id="训练样本不足（过拟合）"><a href="#训练样本不足（过拟合）" class="headerlink" title="训练样本不足（过拟合）"></a>训练样本不足（过拟合）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit_and_plot(poly_features[<span class="number">0</span>:<span class="number">2</span>, :], poly_features[n_train:, :], labels[<span class="number">0</span>:<span class="number">2</span>], labels[n_train:])</span><br></pre></td></tr></table></figure><pre><code>final epoch: train loss 3.7109122276306152 test loss 19.022382736206055weight: tensor([[ 0.2270, -2.5253,  4.9701]]) bias: tensor([0.8091])</code></pre><img src="https://cdn.kesci.com/rt_upload/AB13F65A70A9484788F8004E427EC290/q5y1xm14ab.png"><h1 id="权重衰减"><a href="#权重衰减" class="headerlink" title="权重衰减"></a>权重衰减</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>权重衰减等价于 $L_2$ 范数正则化（regularization）。正则化通过为模型损失函数添加惩罚项使学出的模型参数值较小，是应对过拟合的常用手段。</p><h2 id="L2-范数正则化（regularization）"><a href="#L2-范数正则化（regularization）" class="headerlink" title="L2 范数正则化（regularization）"></a>L2 范数正则化（regularization）</h2><p>$L_2$范数正则化在模型原损失函数基础上添加$L_2$范数惩罚项，从而得到训练所需要最小化的函数。$L_2$范数惩罚项指的是模型权重参数每个元素的平方和与一个正的常数的乘积。以线性回归中的线性回归损失函数为例</p><p>$$<br>\ell(w_1, w_2, b) = \frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right)^2<br>$$</p><p>其中$w_1, w_2$是权重参数，$b$是偏差参数，样本$i$的输入为$x_1^{(i)}, x_2^{(i)}$，标签为$y^{(i)}$，样本数为$n$。将权重参数用向量$\boldsymbol{w} = [w_1, w_2]$表示，带有$L_2$范数惩罚项的新损失函数为</p><p>$$<br>\ell(w_1, w_2, b) + \frac{\lambda}{2n} |\boldsymbol{w}|^2,<br>$$</p><p>其中超参数$\lambda &gt; 0$。当权重参数均为0时，惩罚项最小。当$\lambda$较大时，惩罚项在损失函数中的比重较大，这通常会使学到的权重参数的元素较接近0。当$\lambda$设为0时，惩罚项完全不起作用。上式中$L_2$范数平方$|\boldsymbol{w}|^2$展开后得到$w_1^2 + w_2^2$。<br>有了$L_2$范数惩罚项后，在小批量随机梯度下降中，我们将线性回归一节中权重$w_1$和$w_2$的迭代方式更改为</p><p>$$<br>\begin{aligned} w_1 &amp;\leftarrow \left(1- \frac{\eta\lambda}{|\mathcal{B}|} \right)w_1 - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}x_1^{(i)} \left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right),\ w_2 &amp;\leftarrow \left(1- \frac{\eta\lambda}{|\mathcal{B}|} \right)w_2 - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}x_2^{(i)} \left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right). \end{aligned}<br>$$</p><p>可见，$L_2$范数正则化令权重$w_1$和$w_2$先自乘小于1的数，再减去不含惩罚项的梯度。因此，$L_2$范数正则化又叫权重衰减。权重衰减通过惩罚绝对值较大的模型参数为需要学习的模型增加了限制，这可能对过拟合有效。</p><h2 id="高维线性回归实验从零开始的实现"><a href="#高维线性回归实验从零开始的实现" class="headerlink" title="高维线性回归实验从零开始的实现"></a>高维线性回归实验从零开始的实现</h2><p>下面，我们以高维线性回归为例来引入一个过拟合问题，并使用权重衰减来应对过拟合。设数据样本特征的维度为$p$。对于训练数据集和测试数据集中特征为$x_1, x_2, \ldots, x_p$的任一样本，我们使用如下的线性函数来生成该样本的标签：</p><p>$$<br>y = 0.05 + \sum_{i = 1}^p 0.01x_i + \epsilon<br>$$</p><p>其中噪声项$\epsilon$服从均值为0、标准差为0.01的正态分布。为了较容易地观察过拟合，我们考虑高维线性回归问题，如设维度$p=200$；同时，我们特意把训练数据集的样本数设低，如20。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.3.0</code></pre><h2 id="初始化模型参数-1"><a href="#初始化模型参数-1" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><p>与前面观察过拟合和欠拟合现象的时候相似，在这里不再解释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n_train, n_test, num_inputs = <span class="number">20</span>, <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">true_w, true_b = torch.ones(num_inputs, <span class="number">1</span>) * <span class="number">0.01</span>, <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">features = torch.randn((n_train + n_test, num_inputs))</span><br><span class="line">labels = torch.matmul(features, true_w) + true_b</span><br><span class="line">labels += torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=labels.size()), dtype=torch.float)</span><br><span class="line">train_features, test_features = features[:n_train, :], features[n_train:, :]</span><br><span class="line">train_labels, test_labels = labels[:n_train], labels[n_train:]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义参数初始化函数，初始化模型参数并且附上梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_params</span><span class="params">()</span>:</span></span><br><span class="line">    w = torch.randn((num_inputs, <span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">    b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> [w, b]</span><br></pre></td></tr></table></figure><h2 id="定义L2范数惩罚项"><a href="#定义L2范数惩罚项" class="headerlink" title="定义L2范数惩罚项"></a>定义L2范数惩罚项</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l2_penalty</span><span class="params">(w)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (w**<span class="number">2</span>).sum() / <span class="number">2</span> <span class="comment"># 平方和</span></span><br></pre></td></tr></table></figure><h2 id="定义训练和测试"><a href="#定义训练和测试" class="headerlink" title="定义训练和测试"></a>定义训练和测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">batch_size, num_epochs, lr = <span class="number">1</span>, <span class="number">100</span>, <span class="number">0.003</span></span><br><span class="line">net, loss = d2l.linreg, d2l.squared_loss</span><br><span class="line"></span><br><span class="line">dataset = torch.utils.data.TensorDataset(train_features, train_labels)</span><br><span class="line">train_iter = torch.utils.data.DataLoader(dataset, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_and_plot</span><span class="params">(lambd)</span>:</span> <span class="comment"># 重写</span></span><br><span class="line">    w, b = init_params()</span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="comment">## 添加了L2范数惩罚项</span></span><br><span class="line">            l = loss(net(X, w, b), y) + lambd * l2_penalty(w)</span><br><span class="line">            l = l.sum()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> w.grad <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                w.grad.data.zero_()</span><br><span class="line">                b.grad.data.zero_()</span><br><span class="line">            l.backward()</span><br><span class="line">            d2l.sgd([w, b], lr, batch_size)</span><br><span class="line">        train_ls.append(loss(net(train_features, w, b), train_labels).mean().item())</span><br><span class="line">        test_ls.append(loss(net(test_features, w, b), test_labels).mean().item())</span><br><span class="line">    d2l.semilogy(range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, <span class="string">'epochs'</span>, <span class="string">'loss'</span>,</span><br><span class="line">                 range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), test_ls, [<span class="string">'train'</span>, <span class="string">'test'</span>])</span><br><span class="line">    print(<span class="string">'L2 norm of w:'</span>, w.norm().item())</span><br></pre></td></tr></table></figure><h2 id="观察过拟合"><a href="#观察过拟合" class="headerlink" title="观察过拟合"></a>观察过拟合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit_and_plot(lambd=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><pre><code>L2 norm of w: 12.428479194641113</code></pre><img src="https://cdn.kesci.com/rt_upload/C27406AAA0FD41C6801D55ED4B25D5EA/q5y22u2fu8.svg"><h2 id="使用权重衰减"><a href="#使用权重衰减" class="headerlink" title="使用权重衰减"></a>使用权重衰减</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit_and_plot(lambd=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>L2 norm of w: 0.06141486391425133</code></pre><img src="https://cdn.kesci.com/rt_upload/0770D8C23B8144C59D13D24390E471F0/q5y23myxux.svg"><h2 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_and_plot_pytorch</span><span class="params">(wd)</span>:</span></span><br><span class="line">    <span class="comment"># 对权重参数衰减。权重名称一般是以weight结尾</span></span><br><span class="line">    net = nn.Linear(num_inputs, <span class="number">1</span>)</span><br><span class="line">    nn.init.normal_(net.weight, mean=<span class="number">0</span>, std=<span class="number">1</span>)</span><br><span class="line">    nn.init.normal_(net.bias, mean=<span class="number">0</span>, std=<span class="number">1</span>)</span><br><span class="line">    optimizer_w = torch.optim.SGD(params=[net.weight], lr=lr, weight_decay=wd) <span class="comment"># 对权重参数衰减</span></span><br><span class="line">    optimizer_b = torch.optim.SGD(params=[net.bias], lr=lr)  <span class="comment"># 不对偏差参数衰减</span></span><br><span class="line">    </span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            l = loss(net(X), y).mean()</span><br><span class="line">            optimizer_w.zero_grad()</span><br><span class="line">            optimizer_b.zero_grad()</span><br><span class="line">            </span><br><span class="line">            l.backward()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 对两个optimizer实例分别调用step函数，从而分别更新权重和偏差</span></span><br><span class="line">            optimizer_w.step()</span><br><span class="line">            optimizer_b.step()</span><br><span class="line">        train_ls.append(loss(net(train_features), train_labels).mean().item())</span><br><span class="line">        test_ls.append(loss(net(test_features), test_labels).mean().item())</span><br><span class="line">    d2l.semilogy(range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, <span class="string">'epochs'</span>, <span class="string">'loss'</span>,</span><br><span class="line">                 range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), test_ls, [<span class="string">'train'</span>, <span class="string">'test'</span>])</span><br><span class="line">    print(<span class="string">'L2 norm of w:'</span>, net.weight.data.norm().item())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit_and_plot_pytorch(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><pre><code>L2 norm of w: 12.875502586364746</code></pre><img src="https://cdn.kesci.com/rt_upload/525D01167F0E40509495588D6B0A0FB9/q5y25tzbw3.svg"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit_and_plot_pytorch(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>L2 norm of w: 0.0424627847969532</code></pre><img src="https://cdn.kesci.com/rt_upload/3FAACA854B9545A8ADADDEB6EE17A680/q5y25uhz0n.svg"><h1 id="丢弃法"><a href="#丢弃法" class="headerlink" title="丢弃法"></a>丢弃法</h1><p>多层感知机中神经网络图描述了一个单隐藏层的多层感知机。其中输入个数为4，隐藏单元个数为5，且隐藏单元$h_i$（$i=1, \ldots, 5$）的计算表达式为</p><p>$$<br>h_i = \phi\left(x_1 w_{1i} + x_2 w_{2i} + x_3 w_{3i} + x_4 w_{4i} + b_i\right)<br>$$</p><p>这里$\phi$是激活函数，$x_1, \ldots, x_4$是输入，隐藏单元$i$的权重参数为$w_{1i}, \ldots, w_{4i}$，偏差参数为$b_i$。当对该隐藏层使用丢弃法时，该层的隐藏单元将有一定概率被丢弃掉。设丢弃概率为$p$，那么有$p$的概率$h_i$会被清零，有$1-p$的概率$h_i$会除以$1-p$做拉伸。丢弃概率是丢弃法的超参数。具体来说，设随机变量$\xi_i$为0和1的概率分别为$p$和$1-p$。使用丢弃法时我们计算新的隐藏单元$h_i’$</p><p>$$<br>h_i’ = \frac{\xi_i}{1-p} h_i<br>$$</p><p>由于$E(\xi_i) = 1-p$，因此</p><p>$$<br>E(h_i’) = \frac{E(\xi_i)}{1-p}h_i = h_i<br>$$</p><p>即丢弃法不改变其输入的期望值。让我们对之前多层感知机的神经网络中的隐藏层使用丢弃法，一种可能的结果如图所示，其中$h_2$和$h_5$被清零。这时输出值的计算不再依赖$h_2$和$h_5$，在反向传播时，与这两个隐藏单元相关的权重的梯度均为0。由于在训练中隐藏层神经元的丢弃是随机的，即$h_1, \ldots, h_5$都有可能被清零，输出层的计算无法过度依赖$h_1, \ldots, h_5$中的任一个，从而在训练模型时起到正则化的作用，并可以用来应对过拟合。在测试模型时，我们为了拿到更加确定性的结果，一般不使用丢弃法</p><p><img src="https://cdn.kesci.com/upload/image/q5jd69in3m.png?imageView2/0/w/960/h/960" alt="Image Name"></p><h2 id="丢弃法从零开始的实现"><a href="#丢弃法从零开始的实现" class="headerlink" title="丢弃法从零开始的实现"></a>丢弃法从零开始的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.3.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout</span><span class="params">(X, drop_prob)</span>:</span></span><br><span class="line">    X = X.float()</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= drop_prob &lt;= <span class="number">1</span></span><br><span class="line">    keep_prob = <span class="number">1</span> - drop_prob</span><br><span class="line">    <span class="comment"># 这种情况下把全部元素都丢弃</span></span><br><span class="line">    <span class="keyword">if</span> keep_prob == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> torch.zeros_like(X)</span><br><span class="line">    mask = (torch.rand(X.shape) &lt; keep_prob).float()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mask * X / keep_prob</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>).view(<span class="number">2</span>, <span class="number">8</span>)</span><br><span class="line">dropout(X, <span class="number">0</span>) <span class="comment"># 丢弃率0</span></span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.],        [ 8.,  9., 10., 11., 12., 13., 14., 15.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dropout(X, <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.,  2.,  4.,  0.,  8.,  0.,  0.,  0.],        [ 0., 18.,  0.,  0., 24.,  0., 28., 30.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dropout(X, <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0., 0., 0., 0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0., 0., 0., 0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数的初始化</span></span><br><span class="line">num_inputs, num_outputs, num_hiddens1, num_hiddens2 = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span>, <span class="number">256</span></span><br><span class="line"></span><br><span class="line">W1 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_inputs, num_hiddens1)), dtype=torch.float, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b1 = torch.zeros(num_hiddens1, requires_grad=<span class="literal">True</span>)</span><br><span class="line">W2 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_hiddens1, num_hiddens2)), dtype=torch.float, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b2 = torch.zeros(num_hiddens2, requires_grad=<span class="literal">True</span>)</span><br><span class="line">W3 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_hiddens2, num_outputs)), dtype=torch.float, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b3 = torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">params = [W1, b1, W2, b2, W3, b3]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drop_prob1, drop_prob2 = <span class="number">0.2</span>, <span class="number">0.5</span> <span class="comment"># 两层隐藏层</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span><span class="params">(X, is_training=True)</span>:</span></span><br><span class="line">    X = X.view(<span class="number">-1</span>, num_inputs)</span><br><span class="line">    H1 = (torch.matmul(X, W1) + b1).relu()</span><br><span class="line">    <span class="keyword">if</span> is_training:  <span class="comment"># 只在训练模型时使用丢弃法</span></span><br><span class="line">        H1 = dropout(H1, drop_prob1)  <span class="comment"># 在第一层全连接后添加丢弃层</span></span><br><span class="line">    H2 = (torch.matmul(H1, W2) + b2).relu()</span><br><span class="line">    <span class="keyword">if</span> is_training:</span><br><span class="line">        H2 = dropout(H2, drop_prob2)  <span class="comment"># 在第二层全连接后添加丢弃层</span></span><br><span class="line">    <span class="keyword">return</span> torch.matmul(H2, W3) + b3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy</span><span class="params">(data_iter, net)</span>:</span></span><br><span class="line">    acc_sum, n = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        <span class="keyword">if</span> isinstance(net, torch.nn.Module):</span><br><span class="line">            net.eval() <span class="comment"># 评估模式, 这会关闭dropout</span></span><br><span class="line">            acc_sum += (net(X).argmax(dim=<span class="number">1</span>) == y).float().sum().item()</span><br><span class="line">            net.train() <span class="comment"># 改回训练模式</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 自定义的模型</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">'is_training'</span> <span class="keyword">in</span> net.__code__.co_varnames): <span class="comment"># 如果有is_training这个参数</span></span><br><span class="line">                <span class="comment"># 将is_training设置成False</span></span><br><span class="line">                acc_sum += (net(X, is_training=<span class="literal">False</span>).argmax(dim=<span class="number">1</span>) == y).float().sum().item() </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                acc_sum += (net(X).argmax(dim=<span class="number">1</span>) == y).float().sum().item() </span><br><span class="line">        n += y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> acc_sum / n</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr, batch_size = <span class="number">5</span>, <span class="number">100.0</span>, <span class="number">256</span>  <span class="comment"># 这里的学习率设置的很大，原因与之前相同。</span></span><br><span class="line">loss = torch.nn.CrossEntropyLoss()</span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, root=<span class="string">'/home/kesci/input/FashionMNIST2065'</span>)</span><br><span class="line">d2l.train_ch3(</span><br><span class="line">    net,</span><br><span class="line">    train_iter,</span><br><span class="line">    test_iter,</span><br><span class="line">    loss,</span><br><span class="line">    num_epochs,</span><br><span class="line">    batch_size,</span><br><span class="line">    params,</span><br><span class="line">    lr)</span><br></pre></td></tr></table></figure><pre><code>epoch 1, loss 0.0046, train acc 0.545, test acc 0.725epoch 2, loss 0.0023, train acc 0.785, test acc 0.790epoch 3, loss 0.0019, train acc 0.821, test acc 0.838epoch 4, loss 0.0017, train acc 0.840, test acc 0.805epoch 5, loss 0.0016, train acc 0.849, test acc 0.828</code></pre><h2 id="简洁实现-1"><a href="#简洁实现-1" class="headerlink" title="简洁实现"></a>简洁实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">        d2l.FlattenLayer(),</span><br><span class="line">        nn.Linear(num_inputs, num_hiddens1),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Dropout(drop_prob1),</span><br><span class="line">        nn.Linear(num_hiddens1, num_hiddens2), </span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Dropout(drop_prob2),</span><br><span class="line">        nn.Linear(num_hiddens2, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> net.parameters():</span><br><span class="line">    nn.init.normal_(param, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.5</span>)</span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, <span class="literal">None</span>, <span class="literal">None</span>, optimizer)</span><br></pre></td></tr></table></figure><pre><code>epoch 1, loss 0.0046, train acc 0.548, test acc 0.719epoch 2, loss 0.0023, train acc 0.787, test acc 0.780epoch 3, loss 0.0019, train acc 0.820, test acc 0.830epoch 4, loss 0.0017, train acc 0.840, test acc 0.814epoch 5, loss 0.0016, train acc 0.847, test acc 0.848</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>欠拟合现象：模型无法达到一个较低的误差，增加模型复杂度</p></li><li><p>过拟合现象：训练误差较低但是泛化误差依然较高，二者相差较大，增加模型样本，梯度衰减或丢弃法</p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
      <category term="训练误差/泛化误差" scheme="http://yoursite.com/tags/%E8%AE%AD%E7%BB%83%E8%AF%AF%E5%B7%AE-%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE/"/>
    
      <category term="训练集、验证集、测试集" scheme="http://yoursite.com/tags/%E8%AE%AD%E7%BB%83%E9%9B%86%E3%80%81%E9%AA%8C%E8%AF%81%E9%9B%86%E3%80%81%E6%B5%8B%E8%AF%95%E9%9B%86/"/>
    
      <category term="k折交叉验证" scheme="http://yoursite.com/tags/k%E6%8A%98%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/"/>
    
      <category term="过拟合" scheme="http://yoursite.com/tags/%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    
      <category term="欠拟合" scheme="http://yoursite.com/tags/%E6%AC%A0%E6%8B%9F%E5%90%88/"/>
    
      <category term="梯度衰减" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6%E8%A1%B0%E5%87%8F/"/>
    
      <category term="权重衰减" scheme="http://yoursite.com/tags/%E6%9D%83%E9%87%8D%E8%A1%B0%E5%87%8F/"/>
    
      <category term="dropout" scheme="http://yoursite.com/tags/dropout/"/>
    
  </entry>
  
  <entry>
    <title>Task1.6 循环神经网络基础</title>
    <link href="http://yoursite.com/2020/02/19/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/02/19/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2020-02-19T10:05:36.064Z</published>
    <updated>2020-02-19T10:04:58.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p>本节介绍循环神经网络，下图展示了如何基于循环神经网络实现语言模型。我们的目的是基于当前的输入与过去的输入序列，预测序列的下一个字符。循环神经网络引入一个隐藏变量$H$，用$H_{t}$表示$H$在时间步$t$的值。$H_{t}$的计算基于$X_{t}$和$H_{t-1}$，可以认为$H_{t}$记录了到当前字符为止的序列信息，利用$H_{t}$对序列的下一个字符进行预测。<br><img src="https://cdn.kesci.com/upload/image/q5jkm0v44i.png?imageView2/0/w/640/h/640" alt="Image Name"></p><h2 id="循环神经网络的构造"><a href="#循环神经网络的构造" class="headerlink" title="循环神经网络的构造"></a>循环神经网络的构造</h2><p>我们先看循环神经网络的具体构造。假设$\boldsymbol{X}_t \in \mathbb{R}^{n \times d}$是时间步$t$的小批量输入，$\boldsymbol{H}_t \in \mathbb{R}^{n \times h}$是该时间步的隐藏变量，则：</p><p>$$<br>\boldsymbol{H}<em>t = \phi(\boldsymbol{X}_t \boldsymbol{W}</em>{xh} + \boldsymbol{H}<em>{t-1} \boldsymbol{W}</em>{hh} + \boldsymbol{b}_h).<br>$$</p><p>其中，$\boldsymbol{W}<em>{xh} \in \mathbb{R}^{d \times h}$，$\boldsymbol{W}</em>{hh} \in \mathbb{R}^{h \times h}$，$\boldsymbol{b}<em>{h} \in \mathbb{R}^{1 \times h}$，$\phi$函数是非线性激活函数。由于引入了$\boldsymbol{H}</em>{t-1} \boldsymbol{W}<em>{hh}$，$H</em>{t}$能够捕捉截至当前时间步的序列的历史信息，就像是神经网络当前时间步的状态或记忆一样。由于$H_{t}$的计算基于$H_{t-1}$，上式的计算是循环的，使用循环计算的网络即循环神经网络（recurrent neural network）。</p><p>在时间步$t$，输出层的输出为：</p><p>$$<br>\boldsymbol{O}<em>t = \boldsymbol{H}_t \boldsymbol{W}</em>{hq} + \boldsymbol{b}_q.<br>$$</p><p>其中$\boldsymbol{W}_{hq} \in \mathbb{R}^{h \times q}$，$\boldsymbol{b}_q \in \mathbb{R}^{1 \times q}$。</p><h2 id="从零开始实现循环神经网络"><a href="#从零开始实现循环神经网络" class="headerlink" title="从零开始实现循环神经网络"></a>从零开始实现循环神经网络</h2><p>我们先尝试从零开始实现一个基于字符级循环神经网络的语言模型，这里我们使用周杰伦的歌词作为语料，首先我们读入数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>) <span class="comment"># 添加模块搜索路径</span></span><br><span class="line"><span class="keyword">import</span> d2l_jay9460 <span class="keyword">as</span> d2l </span><br><span class="line">(corpus_indices, char_to_idx, idx_to_char, vocab_size) = d2l.load_data_jay_lyrics() <span class="comment"># 导入数据库</span></span><br><span class="line">device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br></pre></td></tr></table></figure><h3 id="one-hot向量"><a href="#one-hot向量" class="headerlink" title="one-hot向量"></a>one-hot向量</h3><p>我们需要将字符表示成向量，这里采用one-hot向量。假设词典大小是$N$，每次字符对应一个从$0$到$N-1$的唯一的索引，则该字符的向量是一个长度为$N$的向量，若字符的索引是$i$，则该向量的第$i$个位置为$1$，其他位置为$0$。下面分别展示了索引为0和2的one-hot向量，向量长度等于词典大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot</span><span class="params">(x, n_class, dtype=torch.float32)</span>:</span> </span><br><span class="line">    <span class="comment"># x : 一维向量，每个元素都是字符的索引； n_class: 字典大小；dtype: 指定返回向量数值类型</span></span><br><span class="line">    result = torch.zeros(x.shape[<span class="number">0</span>], n_class, dtype=dtype, device=x.device)  <span class="comment"># shape: (n, n_class)</span></span><br><span class="line">    result.scatter_(<span class="number">1</span>, x.long().view(<span class="number">-1</span>, <span class="number">1</span>), <span class="number">1</span>)  <span class="comment"># scatter: result[i, x[i, 0]] = 1，每一行对应元素改写成1</span></span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">    </span><br><span class="line">x = torch.tensor([<span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">x_one_hot = one_hot(x, vocab_size)</span><br><span class="line">print(x_one_hot)</span><br><span class="line">print(x_one_hot.shape)</span><br><span class="line">print(x_one_hot.sum(axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 0., 0.,  ..., 0., 0., 0.],        [0., 0., 1.,  ..., 0., 0., 0.]])torch.Size([2, 1027])tensor([1., 1.])</code></pre><p>我们每次采样的小批量的形状是（批量大小, 时间步数）。下面的函数将这样的小批量变换成数个形状为（批量大小, 词典大小）的矩阵，矩阵个数等于时间步数。也就是说，时间步$t$的输入为$\boldsymbol{X}_t \in \mathbb{R}^{n \times d}$，其中$n$为批量大小，$d$为词向量大小，即one-hot向量长度（词典大小）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_onehot</span><span class="params">(X, n_class)</span>:</span> <span class="comment"># X：小批量 </span></span><br><span class="line">    <span class="keyword">return</span> [one_hot(X[:, i], n_class) <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">1</span>])] <span class="comment"># list 长度为时间步数</span></span><br><span class="line"></span><br><span class="line">X = torch.arange(<span class="number">10</span>).view(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">inputs = to_onehot(X, vocab_size)</span><br><span class="line">print(len(inputs), inputs[<span class="number">0</span>].shape)</span><br></pre></td></tr></table></figure><pre><code>5 torch.Size([2, 1027])</code></pre><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">num_inputs, num_hiddens, num_outputs = vocab_size, <span class="number">256</span>, vocab_size</span><br><span class="line"><span class="comment"># num_inputs: d</span></span><br><span class="line"><span class="comment"># num_hiddens: h, 隐藏单元的个数是超参数</span></span><br><span class="line"><span class="comment"># num_outputs: q</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span><span class="params">()</span>:</span> </span><br><span class="line">    <span class="comment"># 构造、初始化模型参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_one</span><span class="params">(shape)</span>:</span> <span class="comment"># 随机初始化</span></span><br><span class="line">        param = torch.zeros(shape, device=device, dtype=torch.float32)</span><br><span class="line">        nn.init.normal_(param, <span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.nn.Parameter(param)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐藏层参数</span></span><br><span class="line">    W_xh = _one((num_inputs, num_hiddens))</span><br><span class="line">    W_hh = _one((num_hiddens, num_hiddens))</span><br><span class="line">    b_h = torch.nn.Parameter(torch.zeros(num_hiddens, device=device))</span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = _one((num_hiddens, num_outputs))</span><br><span class="line">    b_q = torch.nn.Parameter(torch.zeros(num_outputs, device=device))</span><br><span class="line">    <span class="keyword">return</span> (W_xh, W_hh, b_h, W_hq, b_q) <span class="comment"># tuple</span></span><br></pre></td></tr></table></figure><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>函数<code>rnn</code>用循环的方式依次完成循环神经网络每个时间步的计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rnn</span><span class="params">(inputs, state, params)</span>:</span></span><br><span class="line">   <span class="comment"># inputs和outputs皆为num_steps个形状为(batch_size, vocab_size)的矩阵</span></span><br><span class="line">   <span class="comment"># state： 状态初始值，元组</span></span><br><span class="line">    W_xh, W_hh, b_h, W_hq, b_q = params</span><br><span class="line">    H, = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        H = torch.tanh(torch.matmul(X, W_xh) + torch.matmul(H, W_hh) + b_h)</span><br><span class="line">        Y = torch.matmul(H, W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> outputs, (H,) <span class="comment"># 返回H，以便相邻采样</span></span><br></pre></td></tr></table></figure><p>函数init_rnn_state初始化隐藏变量，这里的返回值是一个元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_rnn_state</span><span class="params">(batch_size, num_hiddens, device)</span>:</span></span><br><span class="line">    <span class="comment"># 构造、初始化模型参数 </span></span><br><span class="line">    <span class="comment"># bath_size: 批量大小，num_hiddens: 隐藏单元个数h，device：CPU GPU</span></span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device), ) <span class="comment"># 返回元组，元组的长度为1，只包含一个元素</span></span><br></pre></td></tr></table></figure><p>做个简单的测试来观察输出结果的个数（时间步数），以及第一个时间步的输出层输出的形状和隐藏状态的形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(X.shape) <span class="comment"># 输入批量，批量大小2，时间步数5</span></span><br><span class="line">print(num_hiddens) </span><br><span class="line">print(vocab_size) </span><br><span class="line">state = init_rnn_state(X.shape[<span class="number">0</span>], num_hiddens, device) </span><br><span class="line">inputs = to_onehot(X.to(device), vocab_size)</span><br><span class="line">params = get_params()</span><br><span class="line">outputs, state_new = rnn(inputs, state, params) </span><br><span class="line">print(len(inputs), inputs[<span class="number">0</span>].shape) <span class="comment"># 时间步数5，列表每个元素：inputs[0].shape</span></span><br><span class="line">print(len(outputs), outputs[<span class="number">0</span>].shape) <span class="comment"># 同input</span></span><br><span class="line">print(len(state), state[<span class="number">0</span>].shape) <span class="comment"># tuple</span></span><br><span class="line">print(len(state_new), state_new[<span class="number">0</span>].shape)</span><br></pre></td></tr></table></figure><pre><code>torch.Size([2, 5])25610275 torch.Size([2, 1027])5 torch.Size([2, 1027])1 torch.Size([2, 256])1 torch.Size([2, 256])</code></pre><h3 id="裁剪梯度"><a href="#裁剪梯度" class="headerlink" title="裁剪梯度"></a>裁剪梯度</h3><p>循环神经网络中较容易出现梯度衰减或梯度爆炸，这会导致网络几乎无法训练。<br>原因：BPTT，梯度幂指数为时间步数，时间步数增加，导致梯度衰减或梯度爆炸。<br>裁剪梯度（clip gradient）是一种应对梯度爆炸的方法。假设我们把所有模型参数的梯度拼接成一个向量 $\boldsymbol{g}$，并设裁剪的阈值是$\theta$。裁剪后的梯度</p><p>$$<br>\min\left(\frac{\theta}{|\boldsymbol{g}|}, 1\right)\boldsymbol{g}<br>$$</p><p>的$L_2$范数不超过$\theta$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad_clipping</span><span class="params">(params, theta, device)</span>:</span> </span><br><span class="line">    norm = torch.tensor([<span class="number">0.0</span>], device=device) <span class="comment"># g的L2范数</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        norm += (param.grad.data ** <span class="number">2</span>).sum() <span class="comment"># 梯度的平方和</span></span><br><span class="line">    norm = norm.sqrt().item()</span><br><span class="line">    <span class="keyword">if</span> norm &gt; theta:</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param.grad.data *= (theta / norm)</span><br></pre></td></tr></table></figure><h3 id="定义预测函数"><a href="#定义预测函数" class="headerlink" title="定义预测函数"></a>定义预测函数</h3><p>以下函数基于前缀<code>prefix</code>（含有数个字符的字符串）来预测接下来的<code>num_chars</code>个字符。这个函数稍显复杂，其中我们将循环神经单元<code>rnn</code>设置成了函数参数，这样在后面小节介绍其他循环神经网络时能重复使用这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_rnn</span><span class="params">(prefix, num_chars, rnn, params, init_rnn_state,</span></span></span><br><span class="line"><span class="function"><span class="params">                num_hiddens, vocab_size, device, idx_to_char, char_to_idx)</span>:</span></span><br><span class="line">    state = init_rnn_state(<span class="number">1</span>, num_hiddens, device) </span><br><span class="line">    output = [char_to_idx[prefix[<span class="number">0</span>]]]   <span class="comment"># output记录prefix加上预测的num_chars个字符</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(num_chars + len(prefix) - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 将上一时间步的输出作为当前时间步的输入</span></span><br><span class="line">        X = to_onehot(torch.tensor([[output[<span class="number">-1</span>]]], device=device), vocab_size)</span><br><span class="line">        <span class="comment"># 计算输出和更新隐藏状态</span></span><br><span class="line">        (Y, state) = rnn(X, state, params)</span><br><span class="line">        <span class="comment"># 下一个时间步的输入是prefix里的字符或者当前的最佳预测字符</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; len(prefix) - <span class="number">1</span>:</span><br><span class="line">            output.append(char_to_idx[prefix[t + <span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output.append(Y[<span class="number">0</span>].argmax(dim=<span class="number">1</span>).item())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([idx_to_char[i] <span class="keyword">for</span> i <span class="keyword">in</span> output]) <span class="comment"># 字符串</span></span><br></pre></td></tr></table></figure><p>我们先测试一下<code>predict_rnn</code>函数。我们将根据前缀“分开”创作长度为10个字符（不考虑前缀长度）的一段歌词。因为模型参数为随机值，所以预测结果也是随机的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predict_rnn(<span class="string">'分开'</span>, <span class="number">10</span>, rnn, params, init_rnn_state, num_hiddens, vocab_size,</span><br><span class="line">            device, idx_to_char, char_to_idx)</span><br></pre></td></tr></table></figure><pre><code>&apos;分开涯啊黑其而坦望胖世文&apos;</code></pre><h3 id="困惑度"><a href="#困惑度" class="headerlink" title="困惑度"></a>困惑度</h3><p>我们通常使用困惑度（perplexity）来评价语言模型的好坏。回忆一下<a href="../chapter_deep-learning-basics/softmax-regression.ipynb">“softmax回归”</a>一节中交叉熵损失函数的定义。困惑度是对交叉熵损失函数做指数运算后得到的值。特别地，</p><ul><li>最佳情况下，模型总是把标签类别的概率预测为1，此时困惑度为1；</li><li>最坏情况下，模型总是把标签类别的概率预测为0，此时困惑度为正无穷；</li><li>基线情况下，模型总是预测所有类别的概率都相同，此时困惑度为类别个数。</li></ul><p>显然，任何一个有效模型的困惑度必须小于类别个数。在本例中，困惑度必须小于词典大小<code>vocab_size</code>。</p><h3 id="定义模型训练函数"><a href="#定义模型训练函数" class="headerlink" title="定义模型训练函数"></a>定义模型训练函数</h3><p>跟之前章节的模型训练函数相比，这里的模型训练函数有以下几点不同：</p><ol><li>使用困惑度评价模型。</li><li>在迭代模型参数前裁剪梯度。</li><li>对时序数据采用不同采样方法将导致隐藏状态初始化的不同。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_and_predict_rnn</span><span class="params">(rnn, get_params, init_rnn_state, num_hiddens,</span></span></span><br><span class="line"><span class="function"><span class="params">                          vocab_size, device, corpus_indices, idx_to_char,</span></span></span><br><span class="line"><span class="function"><span class="params">                          char_to_idx, is_random_iter, num_epochs, num_steps,</span></span></span><br><span class="line"><span class="function"><span class="params">                          lr, clipping_theta, batch_size, pred_period,</span></span></span><br><span class="line"><span class="function"><span class="params">                          pred_len, prefixes)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_random_iter:</span><br><span class="line">        data_iter_fn = d2l.data_iter_random <span class="comment"># 随机采样</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data_iter_fn = d2l.data_iter_consecutive <span class="comment"># 相邻采样：两个相邻batch训练数据连续，只需要初始化隐藏状态一次</span></span><br><span class="line">        <span class="comment"># 训练过程中，同个epoch，随着batch增大，隐藏变量传播更远，计算开销更大</span></span><br><span class="line">        <span class="comment"># 每个batch开始的时候，把隐藏状态从计算图中分离出来</span></span><br><span class="line">    params = get_params() <span class="comment"># 构造初始化模型参数</span></span><br><span class="line">    loss = nn.CrossEntropyLoss() <span class="comment"># 交叉熵损失函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_random_iter:  <span class="comment"># 如使用相邻采样，在epoch开始时初始化隐藏状态</span></span><br><span class="line">            state = init_rnn_state(batch_size, num_hiddens, device)</span><br><span class="line">        l_sum, n, start = <span class="number">0.0</span>, <span class="number">0</span>, time.time()</span><br><span class="line">        data_iter = data_iter_fn(corpus_indices, batch_size, num_steps, device)</span><br><span class="line">        <span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="keyword">if</span> is_random_iter:  <span class="comment"># 如使用随机采样，在每个小批量更新前初始化隐藏状态</span></span><br><span class="line">                state = init_rnn_state(batch_size, num_hiddens, device)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 否则需要使用detach函数从计算图分离隐藏状态</span></span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> state:</span><br><span class="line">                    s.detach_()</span><br><span class="line">            <span class="comment"># inputs是num_steps个形状为(batch_size, vocab_size)的矩阵</span></span><br><span class="line">            inputs = to_onehot(X, vocab_size)</span><br><span class="line">            <span class="comment"># outputs有num_steps个形状为(batch_size, vocab_size)的矩阵</span></span><br><span class="line">            (outputs, state) = rnn(inputs, state, params)</span><br><span class="line">            <span class="comment"># 拼接之后形状为(num_steps * batch_size, vocab_size)</span></span><br><span class="line">            outputs = torch.cat(outputs, dim = <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># Y的形状是(batch_size, num_steps)，转置后再变成形状为</span></span><br><span class="line">            <span class="comment"># (num_steps * batch_size,)的向量，这样跟输出的行一一对应</span></span><br><span class="line">            y = torch.flatten(Y.T) </span><br><span class="line">            <span class="comment"># 使用交叉熵损失计算平均分类误差</span></span><br><span class="line">            l = loss(outputs, y.long()) <span class="comment"># outputs: num_steps * batch_size * vocab_size</span></span><br><span class="line">            <span class="comment"># label y: num_steps * batch_size</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 梯度清0</span></span><br><span class="line">            <span class="keyword">if</span> params[<span class="number">0</span>].grad <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">                    param.grad.data.zero_()</span><br><span class="line">            l.backward()</span><br><span class="line">            grad_clipping(params, clipping_theta, device)  <span class="comment"># 裁剪梯度</span></span><br><span class="line">            d2l.sgd(params, lr, <span class="number">1</span>)  <span class="comment"># 因为误差已经取过均值，梯度不用再做平均</span></span><br><span class="line">            l_sum += l.item() * y.shape[<span class="number">0</span>]</span><br><span class="line">            n += y.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % pred_period == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'epoch %d, perplexity %f, time %.2f sec'</span> % (</span><br><span class="line">                epoch + <span class="number">1</span>, math.exp(l_sum / n), time.time() - start))</span><br><span class="line">            <span class="keyword">for</span> prefix <span class="keyword">in</span> prefixes:</span><br><span class="line">                print(<span class="string">' -'</span>, predict_rnn(prefix, pred_len, rnn, params, init_rnn_state,</span><br><span class="line">                    num_hiddens, vocab_size, device, idx_to_char, char_to_idx))</span><br></pre></td></tr></table></figure><h3 id="训练模型并创作歌词"><a href="#训练模型并创作歌词" class="headerlink" title="训练模型并创作歌词"></a>训练模型并创作歌词</h3><p>现在我们可以训练模型了。首先，设置模型超参数。我们将根据前缀“分开”和“不分开”分别创作长度为50个字符（不考虑前缀长度）的一段歌词。我们每过50个迭代周期便根据当前训练的模型创作一段歌词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, num_steps, batch_size, lr, clipping_theta = <span class="number">250</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">1e2</span>, <span class="number">1e-2</span></span><br><span class="line">pred_period, pred_len, prefixes = <span class="number">50</span>, <span class="number">50</span>, [<span class="string">'分开'</span>, <span class="string">'不分开'</span>]</span><br></pre></td></tr></table></figure><p>下面采用随机采样训练模型并创作歌词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_and_predict_rnn(rnn, get_params, init_rnn_state, num_hiddens,</span><br><span class="line">                      vocab_size, device, corpus_indices, idx_to_char,</span><br><span class="line">                      char_to_idx, <span class="literal">True</span>, num_epochs, num_steps, lr,</span><br><span class="line">                      clipping_theta, batch_size, pred_period, pred_len,</span><br><span class="line">                      prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 50, perplexity 72.377805, time 0.72 sec - 分开 我想要再 你 我有 我 你知了  我有 我想 我不要 爱情我 娘子我 我想我 你子我 我想我 你子 - 不分开 我想要  你我的让我疯狂的可爱女人 温坏的让我疯狂的可爱女人 温坏的让我疯狂的可爱女人 温坏的让我epoch 100, perplexity 10.342263, time 0.83 sec - 分开 一直两老三  后悔你的太笑 然杰是你板 我马儿再想 我不能再想 我不能再想 我不能再想 我不能再想 - 不分开吗  是一直的爱女 我想你你的微笑 我都你这的微笑每天都能不到  我知道这里很听一定乡  你的那界坦epoch 150, perplexity 2.860931, time 0.78 sec - 分开 一直两老哭 还是蜡人 温家怕空出 白色蜡烛 温暖了空屋 白色蜡烛 温暖了空屋 白色蜡烛 温暖了空屋 - 不分开吗 我想你爸 你打我妈 这样 从壶你真了每日 我的认真败给黑色幽你 经着心很满药雕晴的门窗 夕阳斜斜epoch 200, perplexity 1.585580, time 0.73 sec - 分开 一只两老 快使用双截棍 哼 哈兮 习使得双截棍 仁北 用里意血 戒指在哭泣 静静躺在抽屉 它所拥有 - 不分开扫把的胖女巫 用拉丁文念咒语啦啦呜 她养的黑猫笑起来像哭 啦啦啦呜 在小村外的溪边 默默等待 娘子 epoch 250, perplexity 1.293091, time 0.76 sec - 分开 沙什么用哭 爱话能美 让家怕空出 白色蜡烛 温暖了空屋 白色蜡烛 温暖了空屋 白色蜡烛 温暖了空屋 - 不分开吗 然后将过去 慢慢温习 让我爱上你 那场悲剧 是你完美演出的一场戏 宁愿心碎哭泣 再狠狠忘记 你爱</code></pre><p>接下来采用相邻采样训练模型并创作歌词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_and_predict_rnn(rnn, get_params, init_rnn_state, num_hiddens,</span><br><span class="line">                      vocab_size, device, corpus_indices, idx_to_char,</span><br><span class="line">                      char_to_idx, <span class="literal">False</span>, num_epochs, num_steps, lr,</span><br><span class="line">                      clipping_theta, batch_size, pred_period, pred_len,</span><br><span class="line">                      prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 50, perplexity 62.846929, time 0.77 sec - 分开 我想我这 你谁我有 我想一场 我有我有 有让我有 你有我有 你有我有 你有我有 你有我有 你有我有 - 不分开 我不要这 我有我有 你有我有 你有我有 你有我有 你有我有 你有我有 你有我有 你有我有 你有我有epoch 100, perplexity 7.427401, time 0.79 sec - 分开 一颗她 一颗两人三步四步 连成线背著背默默许下心愿 我给你的爱写在西元前 深埋在美索不达米亚平 我 - 不分开觉 我想 这样的美旧 我不儿 想情我的太快 像话去对医药箱说 别怪我 别怪我 别你的手我的红处可头 epoch 150, perplexity 2.117438, time 0.79 sec - 分开 一候她 三颗我都起头 有话去对医药箱说 别怪我 别怪我 说你怎么面对我 甩开球我满腔的怒火 我想揍 - 不分开觉 你是 这穿棍血型 就底样直说 三对就什么 到不懂不奇 有对不要走 三对三斗驳 有种什么走 到对什epoch 200, perplexity 1.307415, time 0.73 sec - 分开 问候我 谁地神枪手 巫师 他念念 有词的 对酋长下诅咒 还我骷髅头 这故事 告诉我 印地安的传说  - 不分开觉 你已经离开我 不知不觉 我跟了这节奏 后知后觉 又过了一个秋 后知后觉 我该好好生活 我该好好生epoch 250, perplexity 1.152017, time 0.77 sec - 分开 问候我 谁是神枪手 巫师 他念念 有词的 对酋长下诅咒 还我骷髅头 这故事 是诉我 印地安的传说  - 不分开觉 你已经离开我 不知不觉 我跟了这节奏 后知后觉 后知后觉 迷迷蒙蒙 你给的梦 出现裂缝 隐隐作痛</code></pre><h2 id="循环神经网络的简洁实现"><a href="#循环神经网络的简洁实现" class="headerlink" title="循环神经网络的简洁实现"></a>循环神经网络的简洁实现</h2><h3 id="定义模型-1"><a href="#定义模型-1" class="headerlink" title="定义模型"></a>定义模型</h3><p>我们使用Pytorch中的<code>nn.RNN</code>来构造循环神经网络。在本节中，我们主要关注<code>nn.RNN</code>的以下几个构造函数参数：</p><ul><li><code>input_size</code> - The number of expected features in the input x</li><li><code>hidden_size</code> – The number of features in the hidden state h</li><li><code>nonlinearity</code> – The non-linearity to use. Can be either ‘tanh’ or ‘relu’. Default: ‘tanh’</li><li><code>batch_first</code> – If True, then the input and output tensors are provided as (batch_size, num_steps, input_size). Default: False</li></ul><p>这里的<code>batch_first</code>决定了输入的形状，我们使用默认的参数<code>False</code>，对应的输入形状是 (num_steps, batch_size, input_size)。</p><p><code>forward</code>函数的参数为：</p><ul><li><code>input</code> of shape (num_steps, batch_size, input_size): tensor containing the features of the input sequence.</li><li><code>h_0</code> of shape (num_layers * num_directions, batch_size, hidden_size): tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided. If the RNN is bidirectional, num_directions should be 2, else it should be 1.</li></ul><p><code>forward</code>函数的返回值是：</p><ul><li><code>output</code> of shape (num_steps, batch_size, num_directions * hidden_size): tensor containing the output features (h_t) from the last layer of the RNN, for each t.</li><li><code>h_n</code> of shape (num_layers * num_directions, batch_size, hidden_size): tensor containing the hidden state for t = num_steps.</li></ul><p>现在我们构造一个<code>nn.RNN</code>实例，并用一个简单的例子来看一下输出的形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rnn_layer = nn.RNN(input_size=vocab_size, hidden_size=num_hiddens)</span><br><span class="line">num_steps, batch_size = <span class="number">35</span>, <span class="number">2</span></span><br><span class="line">X = torch.rand(num_steps, batch_size, vocab_size)</span><br><span class="line">state = <span class="literal">None</span></span><br><span class="line">Y, state_new = rnn_layer(X, state)</span><br><span class="line">print(Y.shape, state_new.shape)</span><br></pre></td></tr></table></figure><pre><code>torch.Size([35, 2, 256]) torch.Size([1, 2, 256])</code></pre><p>我们定义一个完整的基于循环神经网络的语言模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RNNModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rnn_layer, vocab_size)</span>:</span></span><br><span class="line">        super(RNNModel, self).__init__()</span><br><span class="line">        self.rnn = rnn_layer</span><br><span class="line">        self.hidden_size = rnn_layer.hidden_size * (<span class="number">2</span> <span class="keyword">if</span> rnn_layer.bidirectional <span class="keyword">else</span> <span class="number">1</span>) </span><br><span class="line">        self.vocab_size = vocab_size</span><br><span class="line">        self.dense = nn.Linear(self.hidden_size, vocab_size) <span class="comment"># rnn_layer 只提供各时间步隐藏状态, 每个时间步的输出</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs, state)</span>:</span></span><br><span class="line">        <span class="comment"># inputs.shape: (batch_size, num_steps)</span></span><br><span class="line">        X = to_onehot(inputs, vocab_size) <span class="comment"># list，长度为num_stpes，，元素：batch_size * vocab_szie</span></span><br><span class="line">        X = torch.stack(X)  <span class="comment"># X.shape: (num_steps, batch_size, vocab_size)</span></span><br><span class="line">        hiddens, state = self.rnn(X, state) </span><br><span class="line">        hiddens = hiddens.view(<span class="number">-1</span>, hiddens.shape[<span class="number">-1</span>])  <span class="comment"># hiddens.shape: (num_steps * batch_size, hidden_size)</span></span><br><span class="line">        output = self.dense(hiddens)</span><br><span class="line">        <span class="keyword">return</span> output, state</span><br></pre></td></tr></table></figure><p>类似的，我们需要实现一个预测函数，与前面的区别在于前向计算和初始化隐藏状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_rnn_pytorch</span><span class="params">(prefix, num_chars, model, vocab_size, device, idx_to_char,</span></span></span><br><span class="line"><span class="function"><span class="params">                      char_to_idx)</span>:</span></span><br><span class="line">    state = <span class="literal">None</span></span><br><span class="line">    output = [char_to_idx[prefix[<span class="number">0</span>]]]  <span class="comment"># output记录prefix加上预测的num_chars个字符</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(num_chars + len(prefix) - <span class="number">1</span>):</span><br><span class="line">        X = torch.tensor([output[<span class="number">-1</span>]], device=device).view(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        (Y, state) = model(X, state)  <span class="comment"># 前向计算不需要传入模型参数</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; len(prefix) - <span class="number">1</span>:</span><br><span class="line">            output.append(char_to_idx[prefix[t + <span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output.append(Y.argmax(dim=<span class="number">1</span>).item())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([idx_to_char[i] <span class="keyword">for</span> i <span class="keyword">in</span> output])</span><br></pre></td></tr></table></figure><p>使用权重为随机值的模型来预测一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = RNNModel(rnn_layer, vocab_size).to(device)</span><br><span class="line">predict_rnn_pytorch(<span class="string">'分开'</span>, <span class="number">10</span>, model, vocab_size, device, idx_to_char, char_to_idx)</span><br></pre></td></tr></table></figure><pre><code>&apos;分开哪同弥C句句脑脑句句&apos;</code></pre><p>接下来实现训练函数，这里只使用了相邻采样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_and_predict_rnn_pytorch</span><span class="params">(model, num_hiddens, vocab_size, device,</span></span></span><br><span class="line"><span class="function"><span class="params">                                corpus_indices, idx_to_char, char_to_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                num_epochs, num_steps, lr, clipping_theta,</span></span></span><br><span class="line"><span class="function"><span class="params">                                batch_size, pred_period, pred_len, prefixes)</span>:</span></span><br><span class="line">    loss = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(), lr=lr)</span><br><span class="line">    model.to(device)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        l_sum, n, start = <span class="number">0.0</span>, <span class="number">0</span>, time.time()</span><br><span class="line">        data_iter = d2l.data_iter_consecutive(corpus_indices, batch_size, num_steps, device) <span class="comment"># 相邻采样</span></span><br><span class="line">        state = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="keyword">if</span> state <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 使用detach函数从计算图分离隐藏状态</span></span><br><span class="line">                <span class="keyword">if</span> isinstance (state, tuple): <span class="comment"># LSTM, state:(h, c)  </span></span><br><span class="line">                    state[<span class="number">0</span>].detach_()</span><br><span class="line">                    state[<span class="number">1</span>].detach_()</span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    state.detach_() <span class="comment"># 分离</span></span><br><span class="line">            (output, state) = model(X, state) <span class="comment"># output.shape: (num_steps * batch_size, vocab_size)</span></span><br><span class="line">            y = torch.flatten(Y.T)</span><br><span class="line">            l = loss(output, y.long())</span><br><span class="line">            </span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l.backward()</span><br><span class="line">            grad_clipping(model.parameters(), clipping_theta, device)</span><br><span class="line">            optimizer.step()</span><br><span class="line">            l_sum += l.item() * y.shape[<span class="number">0</span>]</span><br><span class="line">            n += y.shape[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % pred_period == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'epoch %d, perplexity %f, time %.2f sec'</span> % (</span><br><span class="line">                epoch + <span class="number">1</span>, math.exp(l_sum / n), time.time() - start))</span><br><span class="line">            <span class="keyword">for</span> prefix <span class="keyword">in</span> prefixes:</span><br><span class="line">                print(<span class="string">' -'</span>, predict_rnn_pytorch(</span><br><span class="line">                    prefix, pred_len, model, vocab_size, device, idx_to_char,</span><br><span class="line">                    char_to_idx))</span><br></pre></td></tr></table></figure><p>训练模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, batch_size, lr, clipping_theta = <span class="number">250</span>, <span class="number">32</span>, <span class="number">1e-3</span>, <span class="number">1e-2</span></span><br><span class="line">pred_period, pred_len, prefixes = <span class="number">50</span>, <span class="number">50</span>, [<span class="string">'分开'</span>, <span class="string">'不分开'</span>]</span><br><span class="line">train_and_predict_rnn_pytorch(model, num_hiddens, vocab_size, device,</span><br><span class="line">                            corpus_indices, idx_to_char, char_to_idx,</span><br><span class="line">                            num_epochs, num_steps, lr, clipping_theta,</span><br><span class="line">                            batch_size, pred_period, pred_len, prefixes)</span><br></pre></td></tr></table></figure><pre><code>epoch 50, perplexity 9.973436, time 0.53 sec - 分开 我不了的让我 像的可爱女人 坏坏的让我疯狂的可爱女人 坏坏的让我疯狂的可爱女人 坏坏的让我疯狂的可 - 不分开不 你想你 我不多 想 你不要 我不能再想  不要再想 我想 你想你 我不能不想 我不能你想 我不要epoch 100, perplexity 1.292984, time 0.61 sec - 分开始我不 泪被  三管成回忆 就人在直到 我 它回忆的 太还在一个秋 黄沙录像 是那着我 想开始风呼  - 不分开 你是你在抽离 不知不觉 你已经离开我 不知不觉 我跟了这节奏 后知后觉 又过了一个秋 后知后觉 我epoch 150, perplexity 1.075873, time 0.58 sec - 分开 我不了泪 漂  没有一口 我有悲 什么 多难熬 心穿你 娘子却依旧每日折一枝杨柳 在小村外的溪边河 - 不分开 你是你在抽离 不知不觉 你已经离开我 不知不觉 我跟了这节奏 后知后觉 又过了一个秋 后知后觉 我epoch 200, perplexity 1.034574, time 0.59 sec - 分开 我不了走  为什么来到 这故事 告诉我 印地安的传说 还真是 瞎透了 什么都有 沙漠之中怎么会有泥 - 不分开 你我不带 你 我 能够远远单纯 是些不  是你知道过 是雨的甜 还真下心抽的 娘著空到的溪边河 默epoch 250, perplexity 1.033936, time 0.52 sec - 分开 我不了那个人 又过是好不透 想要是你不会 不知 觉已经成了永垂不朽的诗篇 我给你的爱写在西元前 深 - 不分开 你却已在抽人 快不是再说你 我都会话 你 后知后觉 迷迷蒙蒙 你给的梦 出现裂缝 隐隐作痛 怎么沟</code></pre><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
      <category term="循环神经网络" scheme="http://yoursite.com/tags/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="one-hot向量" scheme="http://yoursite.com/tags/one-hot%E5%90%91%E9%87%8F/"/>
    
      <category term="梯度裁剪" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6%E8%A3%81%E5%89%AA/"/>
    
      <category term="困惑度" scheme="http://yoursite.com/tags/%E5%9B%B0%E6%83%91%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>【图解】随机采样 &amp; 相邻采样 python 实现</title>
    <link href="http://yoursite.com/2020/02/15/sample/"/>
    <id>http://yoursite.com/2020/02/15/sample/</id>
    <published>2020-02-15T12:42:05.234Z</published>
    <updated>2020-02-15T14:32:44.622Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h1><p>下面的代码每次从数据里随机采样一个小批量。其中批量大小<code>batch_size</code>是每个小批量的样本数，<code>num_steps</code>是每个样本所包含的时间步数。<br>在随机采样中，每个样本是原始序列上任意截取的一段序列，相邻的两个随机小批量在原始序列上的位置不一定相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter_random</span><span class="params">(corpus_indices, batch_size, num_steps, device=None)</span>:</span></span><br><span class="line">    <span class="comment"># 减1是因为对于长度为n的序列，X最多只有包含其中的前n - 1个字符</span></span><br><span class="line">    num_examples = (len(corpus_indices) - <span class="number">1</span>) // num_steps  <span class="comment"># 下取整，得到不重叠情况下的样本个数</span></span><br><span class="line">    example_indices = [i * num_steps <span class="keyword">for</span> i <span class="keyword">in</span> range(num_examples)]  <span class="comment"># 每个样本的第一个字符在corpus_indices中的下标</span></span><br><span class="line">    random.shuffle(example_indices)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_data</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="comment"># 返回从i开始的长为num_steps的序列</span></span><br><span class="line">        <span class="keyword">return</span> corpus_indices[i: i + num_steps]</span><br><span class="line">    <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        <span class="comment"># 每次选出batch_size个随机样本</span></span><br><span class="line">        batch_indices = example_indices[i: i + batch_size]  <span class="comment"># 当前batch的各个样本的首字符的下标</span></span><br><span class="line">        X = [_data(j) <span class="keyword">for</span> j <span class="keyword">in</span> batch_indices]</span><br><span class="line">        Y = [_data(j + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> batch_indices]</span><br><span class="line">        <span class="keyword">yield</span> torch.tensor(X, device=device), torch.tensor(Y, device=device)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_seq = list(range(<span class="number">30</span>))</span><br><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter_random(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">6</span>):</span><br><span class="line">    print(<span class="string">'X: '</span>, X, <span class="string">'\nY:'</span>, Y, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><pre><code>X:  tensor([[18, 19, 20, 21, 22, 23],        [ 6,  7,  8,  9, 10, 11]]) Y: tensor([[19, 20, 21, 22, 23, 24],        [ 7,  8,  9, 10, 11, 12]]) X:  tensor([[12, 13, 14, 15, 16, 17],        [ 0,  1,  2,  3,  4,  5]]) Y: tensor([[13, 14, 15, 16, 17, 18],        [ 1,  2,  3,  4,  5,  6]]) </code></pre><p>​</p><h1 id="相邻采样"><a href="#相邻采样" class="headerlink" title="相邻采样"></a>相邻采样</h1><p>在相邻采样中，相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter_consecutive</span><span class="params">(corpus_indices, batch_size, num_steps, device=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">    corpus_len = len(corpus_indices) // batch_size * batch_size  <span class="comment"># 保留下来的序列的长度</span></span><br><span class="line">    corpus_indices = corpus_indices[: corpus_len]  <span class="comment"># 仅保留前corpus_len个字符</span></span><br><span class="line">    indices = torch.tensor(corpus_indices, device=device)</span><br><span class="line">    indices = indices.view(batch_size, <span class="number">-1</span>)  <span class="comment"># resize成(batch_size, )</span></span><br><span class="line">    batch_num = (indices.shape[<span class="number">1</span>] - <span class="number">1</span>) // num_steps</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(batch_num):</span><br><span class="line">        i = i * num_steps</span><br><span class="line">        X = indices[:, i: i + num_steps]</span><br><span class="line">        Y = indices[:, i + <span class="number">1</span>: i + num_steps + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">yield</span> X, Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter_consecutive(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">6</span>):</span><br><span class="line">    print(<span class="string">'X: '</span>, X, <span class="string">'\nY:'</span>, Y, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><pre><code>X:  tensor([[ 0,  1,  2,  3,  4,  5],        [15, 16, 17, 18, 19, 20]]) Y: tensor([[ 1,  2,  3,  4,  5,  6],        [16, 17, 18, 19, 20, 21]]) X:  tensor([[ 6,  7,  8,  9, 10, 11],        [21, 22, 23, 24, 25, 26]]) Y: tensor([[ 7,  8,  9, 10, 11, 12],        [22, 23, 24, 25, 26, 27]]) </code></pre><p>​</p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="图解深度学习代码" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="序列采样" scheme="http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E9%87%87%E6%A0%B7/"/>
    
      <category term="随机采样" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"/>
    
      <category term="相邻采样" scheme="http://yoursite.com/tags/%E7%9B%B8%E9%82%BB%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>Task1.5 语言模型</title>
    <link href="http://yoursite.com/2020/02/15/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2020/02/15/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2020-02-15T08:49:23.873Z</published>
    <updated>2020-02-15T14:32:36.661Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h1><p>一段自然语言文本可以看作是一个离散时间序列，给定一个长度为$T$的词的序列$w_1, w_2, \ldots, w_T$，语言模型的目标就是评估该序列是否合理，即计算该序列的概率：</p><p>$$<br>P(w_1, w_2, \ldots, w_T).<br>$$</p><p>本节我们介绍基于统计的语言模型，主要是$n$元语法（$n$-gram）。在后续内容中，我们将会介绍基于神经网络的语言模型。</p><h2 id="语言模型-1"><a href="#语言模型-1" class="headerlink" title="语言模型"></a>语言模型</h2><p>假设序列$w_1, w_2, \ldots, w_T$中的每个词是依次生成的，我们有</p><p>$$<br>\begin{align<em>}<br>P(w_1, w_2, \ldots, w_T)<br>&amp;= \prod_{t=1}^T P(w_t \mid w_1, \ldots, w_{t-1})\<br>&amp;= P(w_1)P(w_2 \mid w_1) \cdots P(w_T \mid w_1w_2\cdots w_{T-1})<br>\end{align</em>}<br>$$</p><p>例如，一段含有4个词的文本序列的概率</p><p>$$<br>P(w_1, w_2, w_3, w_4) = P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_1, w_2, w_3).<br>$$</p><p>语言模型的参数就是词的概率以及给定前几个词情况下的条件概率。设训练数据集为一个大型文本语料库，如维基百科的所有条目，词的概率可以通过该词在训练数据集中的相对词频来计算，例如，$w_1$的概率可以计算为：</p><p>$$<br>\hat P(w_1) = \frac{n(w_1)}{n}<br>$$</p><p>其中$n(w_1)$为语料库中以$w_1$作为第一个词的文本的数量，$n$为语料库中文本的总数量。</p><p>类似的，给定$w_1$情况下$w_2$的条件概率可以计算为：</p><p>$$<br>\hat P(w_2 \mid w_1) = \frac{n(w_1, w_2)}{n(w_1)}<br>$$</p><p>其中$n(w_1, w_2)$为语料库中以$w_1$作为第一个词，$w_2$作为第二个词的文本的数量。</p><h2 id="n元语法"><a href="#n元语法" class="headerlink" title="n元语法"></a>n元语法</h2><p>序列长度增加，计算和存储多个词共同出现的概率的复杂度会呈指数级增加。$n$元语法通过马尔可夫假设简化模型，马尔科夫假设是指一个词的出现只与前面$n$个词相关，即$n$阶马尔可夫链（Markov chain of order $n$），如果$n=1$，那么有$P(w_3 \mid w_1, w_2) = P(w_3 \mid w_2)$。基于$n-1$阶马尔可夫链，我们可以将语言模型改写为</p><p>$$<br>P(w_1, w_2, \ldots, w_T) = \prod_{t=1}^T P(w_t \mid w_{t-(n-1)}, \ldots, w_{t-1}) .<br>$$</p><p>以上也叫$n$元语法（$n$-grams），它是基于$n - 1$阶马尔可夫链的概率语言模型。例如，当$n=2$时，含有4个词的文本序列的概率就可以改写为：</p><p>$$<br>\begin{align<em>}<br>P(w_1, w_2, w_3, w_4)<br>&amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_1, w_2, w_3)\<br>&amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_2) P(w_4 \mid w_3)<br>\end{align</em>}<br>$$</p><p>当$n$分别为1、2和3时，我们将其分别称作一元语法（unigram）、二元语法（bigram）和三元语法（trigram）。例如，长度为4的序列$w_1, w_2, w_3, w_4$在一元语法、二元语法和三元语法中的概率分别为</p><p>$$<br>\begin{aligned}<br>P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2) P(w_3) P(w_4) ,\<br>P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_2) P(w_4 \mid w_3) ,\<br>P(w_1, w_2, w_3, w_4) &amp;= P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_2, w_3) .<br>\end{aligned}<br>$$</p><p>当$n$较小时，$n$元语法往往并不准确。例如，在一元语法中，由三个词组成的句子“你走先”和“你先走”的概率是一样的。然而，当$n$较大时，$n$元语法需要计算并存储大量的词频和多词相邻频率。</p><p>思考：$n$元语法可能有哪些缺陷？</p><ol><li>参数空间过大</li><li>数据稀疏</li></ol><p><strong>齐夫定律</strong>：（NLP）一个单词出现的频率与它在频率表里的排名成反比</p><h1 id="语言模型数据集"><a href="#语言模型数据集" class="headerlink" title="语言模型数据集"></a>语言模型数据集</h1><h2 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/home/kesci/input/jaychou_lyrics4703/jaychou_lyrics.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    corpus_chars = f.read()</span><br><span class="line">print(len(corpus_chars))</span><br><span class="line">print(corpus_chars[: <span class="number">40</span>])</span><br><span class="line">corpus_chars = corpus_chars.replace(<span class="string">'\n'</span>, <span class="string">' '</span>).replace(<span class="string">'\r'</span>, <span class="string">' '</span>)</span><br><span class="line">corpus_chars = corpus_chars[: <span class="number">10000</span>]</span><br></pre></td></tr></table></figure><pre><code>63282想要有直升机想要和你飞到宇宙去想要和你融化在一起融化在宇宙里我每天每天每</code></pre><h2 id="建立字符索引"><a href="#建立字符索引" class="headerlink" title="建立字符索引"></a>建立字符索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">idx_to_char = list(set(corpus_chars)) <span class="comment"># 去重，得到索引到字符的映射</span></span><br><span class="line">char_to_idx = &#123;char: i <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(idx_to_char)&#125; <span class="comment"># 字符到索引的映射</span></span><br><span class="line">vocab_size = len(char_to_idx)</span><br><span class="line">print(vocab_size)</span><br><span class="line"></span><br><span class="line">corpus_indices = [char_to_idx[char] <span class="keyword">for</span> char <span class="keyword">in</span> corpus_chars]  <span class="comment"># 将每个字符转化为索引，得到一个索引的序列</span></span><br><span class="line">sample = corpus_indices[: <span class="number">20</span>]</span><br><span class="line">print(<span class="string">'chars:'</span>, <span class="string">''</span>.join([idx_to_char[idx] <span class="keyword">for</span> idx <span class="keyword">in</span> sample]))</span><br><span class="line">print(<span class="string">'indices:'</span>, sample)</span><br></pre></td></tr></table></figure><pre><code>1027chars: 想要有直升机 想要和你飞到宇宙去 想要和indices: [187, 378, 49, 9, 25, 801, 185, 187, 378, 240, 575, 551, 954, 433, 168, 151, 185, 187, 378, 240]</code></pre><p>定义函数<code>load_data_jay_lyrics</code>，在后续章节中直接调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data_jay_lyrics</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/home/kesci/input/jaychou_lyrics4703/jaychou_lyrics.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        corpus_chars = f.read()</span><br><span class="line">    corpus_chars = corpus_chars.replace(<span class="string">'\n'</span>, <span class="string">' '</span>).replace(<span class="string">'\r'</span>, <span class="string">' '</span>)</span><br><span class="line">    corpus_chars = corpus_chars[<span class="number">0</span>:<span class="number">10000</span>]</span><br><span class="line">    idx_to_char = list(set(corpus_chars))</span><br><span class="line">    char_to_idx = dict([(char, i) <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(idx_to_char)])</span><br><span class="line">    vocab_size = len(char_to_idx)</span><br><span class="line">    corpus_indices = [char_to_idx[char] <span class="keyword">for</span> char <span class="keyword">in</span> corpus_chars]</span><br><span class="line">    <span class="keyword">return</span> corpus_indices, char_to_idx, idx_to_char, vocab_size</span><br></pre></td></tr></table></figure><h2 id="时序数据的采样"><a href="#时序数据的采样" class="headerlink" title="时序数据的采样"></a>时序数据的采样</h2><p>在训练中我们需要每次随机读取小批量样本和标签。与之前章节的实验数据不同的是，时序数据的一个样本通常包含连续的字符。假设时间步数为5，样本序列为5个字符，即“想”“要”“有”“直”“升”。该样本的标签序列为这些字符分别在训练集中的下一个字符，即“要”“有”“直”“升”“机”，即$X$=“想要有直升”，$Y$=“要有直升机”。</p><p>现在我们考虑序列“想要有直升机，想要和你飞到宇宙去”，如果时间步数为5，有以下可能的样本和标签：</p><ul><li>$X$：“想要有直升”，$Y$：“要有直升机”</li><li>$X$：“要有直升机”，$Y$：“有直升机，”</li><li>$X$：“有直升机，”，$Y$：“直升机，想”</li><li>…</li><li>$X$：“要和你飞到”，$Y$：“和你飞到宇”</li><li>$X$：“和你飞到宇”，$Y$：“你飞到宇宙”</li><li>$X$：“你飞到宇宙”，$Y$：“飞到宇宙去”</li></ul><p>可以看到，如果序列的长度为$T$，时间步数为$n$，那么一共有$T-n$个合法的样本，但是这些样本有大量的重合，我们通常采用更加高效的采样方式。我们有两种方式对时序数据进行采样，分别是随机采样和相邻采样。</p><h3 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h3><p>下面的代码每次从数据里随机采样一个小批量。其中批量大小<code>batch_size</code>是每个小批量的样本数，<code>num_steps</code>是每个样本所包含的时间步数。<br>在随机采样中，每个样本是原始序列上任意截取的一段序列，相邻的两个随机小批量在原始序列上的位置不一定相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter_random</span><span class="params">(corpus_indices, batch_size, num_steps, device=None)</span>:</span></span><br><span class="line">    <span class="comment"># 减1是因为对于长度为n的序列，X最多只有包含其中的前n - 1个字符</span></span><br><span class="line">    num_examples = (len(corpus_indices) - <span class="number">1</span>) // num_steps  <span class="comment"># 下取整，得到不重叠情况下的样本个数</span></span><br><span class="line">    example_indices = [i * num_steps <span class="keyword">for</span> i <span class="keyword">in</span> range(num_examples)]  <span class="comment"># 每个样本的第一个字符在corpus_indices中的下标</span></span><br><span class="line">    random.shuffle(example_indices)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_data</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="comment"># 返回从i开始的长为num_steps的序列</span></span><br><span class="line">        <span class="keyword">return</span> corpus_indices[i: i + num_steps]</span><br><span class="line">    <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        <span class="comment"># 每次选出batch_size个随机样本</span></span><br><span class="line">        batch_indices = example_indices[i: i + batch_size]  <span class="comment"># 当前batch的各个样本的首字符的下标</span></span><br><span class="line">        X = [_data(j) <span class="keyword">for</span> j <span class="keyword">in</span> batch_indices]</span><br><span class="line">        Y = [_data(j + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> batch_indices]</span><br><span class="line">        <span class="keyword">yield</span> torch.tensor(X, device=device), torch.tensor(Y, device=device)</span><br></pre></td></tr></table></figure><p>测试一下这个函数，我们输入从0到29的连续整数作为一个人工序列，设批量大小和时间步数分别为2和6，打印随机采样每次读取的小批量样本的输入<code>X</code>和标签<code>Y</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_seq = list(range(<span class="number">30</span>))</span><br><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter_random(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">6</span>):</span><br><span class="line">    print(<span class="string">'X: '</span>, X, <span class="string">'\nY:'</span>, Y, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><pre><code>X:  tensor([[ 6,  7,  8,  9, 10, 11],        [12, 13, 14, 15, 16, 17]]) Y: tensor([[ 7,  8,  9, 10, 11, 12],        [13, 14, 15, 16, 17, 18]]) X:  tensor([[ 0,  1,  2,  3,  4,  5],        [18, 19, 20, 21, 22, 23]]) Y: tensor([[ 1,  2,  3,  4,  5,  6],        [19, 20, 21, 22, 23, 24]]) </code></pre><p>​</p><h3 id="相邻采样"><a href="#相邻采样" class="headerlink" title="相邻采样"></a>相邻采样</h3><p>在相邻采样中，相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter_consecutive</span><span class="params">(corpus_indices, batch_size, num_steps, device=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">    corpus_len = len(corpus_indices) // batch_size * batch_size  <span class="comment"># 保留下来的序列的长度</span></span><br><span class="line">    corpus_indices = corpus_indices[: corpus_len]  <span class="comment"># 仅保留前corpus_len个字符</span></span><br><span class="line">    indices = torch.tensor(corpus_indices, device=device)</span><br><span class="line">    indices = indices.view(batch_size, <span class="number">-1</span>)  <span class="comment"># resize成(batch_size, )</span></span><br><span class="line">    batch_num = (indices.shape[<span class="number">1</span>] - <span class="number">1</span>) // num_steps</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(batch_num):</span><br><span class="line">        i = i * num_steps</span><br><span class="line">        X = indices[:, i: i + num_steps]</span><br><span class="line">        Y = indices[:, i + <span class="number">1</span>: i + num_steps + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">yield</span> X, Y</span><br></pre></td></tr></table></figure><p>同样的设置下，打印相邻采样每次读取的小批量样本的输入<code>X</code>和标签<code>Y</code>。相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter_consecutive(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">6</span>):</span><br><span class="line">    print(<span class="string">'X: '</span>, X, <span class="string">'\nY:'</span>, Y, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><pre><code>X:  tensor([[ 0,  1,  2,  3,  4,  5],        [15, 16, 17, 18, 19, 20]]) Y: tensor([[ 1,  2,  3,  4,  5,  6],        [16, 17, 18, 19, 20, 21]]) X:  tensor([[ 6,  7,  8,  9, 10, 11],        [21, 22, 23, 24, 25, 26]]) Y: tensor([[ 7,  8,  9, 10, 11, 12],        [22, 23, 24, 25, 26, 27]]) </code></pre><p>​</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
      <category term="随机采样" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7/"/>
    
      <category term="相邻采样" scheme="http://yoursite.com/tags/%E7%9B%B8%E9%82%BB%E9%87%87%E6%A0%B7/"/>
    
      <category term="n-gram" scheme="http://yoursite.com/tags/n-gram/"/>
    
      <category term="齐夫定律" scheme="http://yoursite.com/tags/%E9%BD%90%E5%A4%AB%E5%AE%9A%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>Task1.4 文本预处理</title>
    <link href="http://yoursite.com/2020/02/15/%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/15/%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86/</id>
    <published>2020-02-15T08:42:16.892Z</published>
    <updated>2020-02-15T14:32:20.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="文本预处理"><a href="#文本预处理" class="headerlink" title="文本预处理"></a>文本预处理</h1><p>文本是一类序列数据，一篇文章可以看作是字符或单词的序列，本节将介绍文本数据的常见预处理步骤，预处理通常包括四个步骤：</p><ol><li>读入文本</li><li>分词</li><li>建立字典，将每个词映射到一个唯一的索引（index）</li><li>将文本从词的序列转换为索引的序列，方便输入模型</li></ol><h2 id="读入文本"><a href="#读入文本" class="headerlink" title="读入文本"></a>读入文本</h2><p>我们用一部英文小说，即H. G. Well的<a href="http://www.gutenberg.org/ebooks/35" target="_blank" rel="noopener">Time Machine</a>，作为示例，展示文本预处理的具体过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_time_machine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/home/kesci/input/timemachine7163/timemachine.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = [re.sub(<span class="string">'[^a-z]+'</span>, <span class="string">' '</span>, line.strip().lower()) <span class="keyword">for</span> line <span class="keyword">in</span> f] <span class="comment"># 全部转换为小写，非字母字符替换为空字符</span></span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines = read_time_machine()</span><br><span class="line">print(<span class="string">'# sentences %d'</span> % len(lines))</span><br></pre></td></tr></table></figure><pre><code># sentences 3221</code></pre><h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><p>我们对每个句子进行分词，也就是将一个句子划分成若干个词（token），转换为一个词的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(sentences, token=<span class="string">'word'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Split sentences into word or char tokens"""</span></span><br><span class="line">    <span class="keyword">if</span> token == <span class="string">'word'</span>:</span><br><span class="line">        <span class="keyword">return</span> [sentence.split(<span class="string">' '</span>) <span class="keyword">for</span> sentence <span class="keyword">in</span> sentences] </span><br><span class="line">    <span class="keyword">elif</span> token == <span class="string">'char'</span>:</span><br><span class="line">        <span class="keyword">return</span> [list(sentence) <span class="keyword">for</span> sentence <span class="keyword">in</span> sentences]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'ERROR: unkown token type '</span>+token)</span><br><span class="line"></span><br><span class="line">tokens = tokenize(lines)</span><br><span class="line">tokens[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><pre><code>[[&apos;the&apos;, &apos;time&apos;, &apos;machine&apos;, &apos;by&apos;, &apos;h&apos;, &apos;g&apos;, &apos;wells&apos;, &apos;&apos;], [&apos;&apos;]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">to = tokenize(lines, <span class="string">'char'</span>)</span><br><span class="line">to[<span class="number">0</span>:<span class="number">1</span>]</span><br></pre></td></tr></table></figure><pre><code>[[&apos;t&apos;,  &apos;h&apos;,  &apos;e&apos;,  &apos; &apos;,  &apos;t&apos;,  &apos;i&apos;,  &apos;m&apos;,  &apos;e&apos;,  &apos; &apos;,  &apos;m&apos;,  &apos;a&apos;,  &apos;c&apos;,  &apos;h&apos;,  &apos;i&apos;,  &apos;n&apos;,  &apos;e&apos;,  &apos; &apos;,  &apos;b&apos;,  &apos;y&apos;,  &apos; &apos;,  &apos;h&apos;,  &apos; &apos;,  &apos;g&apos;,  &apos; &apos;,  &apos;w&apos;,  &apos;e&apos;,  &apos;l&apos;,  &apos;l&apos;,  &apos;s&apos;,  &apos; &apos;]]</code></pre><h2 id="建立字典"><a href="#建立字典" class="headerlink" title="建立字典"></a>建立字典</h2><p>为了方便模型处理，我们需要将字符串转换为数字。因此我们需要先构建一个字典（vocabulary），将每个词映射到一个唯一的索引编号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vocab</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tokens, min_freq=<span class="number">0</span>, use_special_tokens=False)</span>:</span></span><br><span class="line">        counter = count_corpus(tokens)  <span class="comment"># 词频 </span></span><br><span class="line">        self.token_freqs = list(counter.items()) <span class="comment"># 词频字典</span></span><br><span class="line">        self.idx_to_token = [] <span class="comment"># 索引 -&gt; 词</span></span><br><span class="line">        <span class="keyword">if</span> use_special_tokens:</span><br><span class="line">            <span class="comment"># padding (the same length), begin of sentence, end of sentence, unknown</span></span><br><span class="line">            self.pad, self.bos, self.eos, self.unk = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">            self.idx_to_token += [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.unk = <span class="number">0</span></span><br><span class="line">            self.idx_to_token += [<span class="string">''</span>]</span><br><span class="line">        self.idx_to_token += [token <span class="keyword">for</span> token, freq <span class="keyword">in</span> self.token_freqs</span><br><span class="line">                        <span class="keyword">if</span> freq &gt;= min_freq <span class="keyword">and</span> token <span class="keyword">not</span> <span class="keyword">in</span> self.idx_to_token] <span class="comment"># 增加词频大于min_freq的词</span></span><br><span class="line">        self.token_to_idx = dict()</span><br><span class="line">        <span class="keyword">for</span> idx, token <span class="keyword">in</span> enumerate(self.idx_to_token):</span><br><span class="line">            self.token_to_idx[token] = idx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.idx_to_token)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(tokens, (list, tuple)):</span><br><span class="line">            <span class="keyword">return</span> self.token_to_idx.get(tokens, self.unk)</span><br><span class="line">        <span class="keyword">return</span> [self.__getitem__(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_tokens</span><span class="params">(self, indices)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(indices, (list, tuple)):</span><br><span class="line">            <span class="keyword">return</span> self.idx_to_token[indices]</span><br><span class="line">        <span class="keyword">return</span> [self.idx_to_token[index] <span class="keyword">for</span> index <span class="keyword">in</span> indices]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_corpus</span><span class="params">(sentences)</span>:</span></span><br><span class="line">    tokens = [tk <span class="keyword">for</span> st <span class="keyword">in</span> sentences <span class="keyword">for</span> tk <span class="keyword">in</span> st]</span><br><span class="line">    <span class="keyword">return</span> collections.Counter(tokens)  <span class="comment"># 返回一个字典，记录每个词的出现次数</span></span><br></pre></td></tr></table></figure><p>我们看一个例子，这里我们尝试用Time Machine作为语料构建字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vocab = Vocab(tokens)</span><br><span class="line">print(list(vocab.token_to_idx.items())[<span class="number">0</span>:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>[(&apos;&apos;, 0), (&apos;the&apos;, 1), (&apos;time&apos;, 2), (&apos;machine&apos;, 3), (&apos;by&apos;, 4), (&apos;h&apos;, 5), (&apos;g&apos;, 6), (&apos;wells&apos;, 7), (&apos;i&apos;, 8), (&apos;traveller&apos;, 9)]</code></pre><p>验证其他函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vocab.token_freqs[<span class="number">0</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><pre><code>[(&apos;the&apos;, 2261), (&apos;time&apos;, 200), (&apos;machine&apos;, 85), (&apos;by&apos;, 103), (&apos;h&apos;, 1), (&apos;g&apos;, 1), (&apos;wells&apos;, 9), (&apos;&apos;, 1282), (&apos;i&apos;, 1267), (&apos;traveller&apos;, 61)]</code></pre><h2 id="将词转为索引"><a href="#将词转为索引" class="headerlink" title="将词转为索引"></a>将词转为索引</h2><p>使用字典，我们可以将原文本中的句子从单词序列转换为索引序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>, <span class="number">10</span>):</span><br><span class="line">    print(<span class="string">'words:'</span>, tokens[i])</span><br><span class="line">    print(<span class="string">'indices:'</span>, vocab[tokens[i]])</span><br></pre></td></tr></table></figure><pre><code>words: [&apos;the&apos;, &apos;time&apos;, &apos;traveller&apos;, &apos;for&apos;, &apos;so&apos;, &apos;it&apos;, &apos;will&apos;, &apos;be&apos;, &apos;convenient&apos;, &apos;to&apos;, &apos;speak&apos;, &apos;of&apos;, &apos;him&apos;, &apos;&apos;]indices: [1, 2, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0]words: [&apos;was&apos;, &apos;expounding&apos;, &apos;a&apos;, &apos;recondite&apos;, &apos;matter&apos;, &apos;to&apos;, &apos;us&apos;, &apos;his&apos;, &apos;grey&apos;, &apos;eyes&apos;, &apos;shone&apos;, &apos;and&apos;]indices: [20, 21, 22, 23, 24, 16, 25, 26, 27, 28, 29, 30]</code></pre><h2 id="用现有工具进行分词"><a href="#用现有工具进行分词" class="headerlink" title="用现有工具进行分词"></a>用现有工具进行分词</h2><p>我们前面介绍的分词方式非常简单，它至少有以下几个缺点:</p><ol><li>标点符号通常可以提供语义信息，但是我们的方法直接将其丢弃了</li><li>类似“shouldn’t”, “doesn’t”这样的词会被错误地处理</li><li>类似”Mr.”, “Dr.”这样的词会被错误地处理</li></ol><p>我们可以通过引入更复杂的规则来解决这些问题，但是事实上，有一些现有的工具可以很好地进行分词，我们在这里简单介绍其中的两个：<a href="https://spacy.io/" target="_blank" rel="noopener">spaCy</a>和<a href="https://www.nltk.org/" target="_blank" rel="noopener">NLTK</a>。</p><p>下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">"Mr. Chen doesn't agree with my suggestion."</span></span><br></pre></td></tr></table></figure><p>spaCy:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_sm'</span>)</span><br><span class="line">doc = nlp(text)</span><br><span class="line">print([token.text <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br></pre></td></tr></table></figure><pre><code>[&apos;Mr.&apos;, &apos;Chen&apos;, &apos;does&apos;, &quot;n&apos;t&quot;, &apos;agree&apos;, &apos;with&apos;, &apos;my&apos;, &apos;suggestion&apos;, &apos;.&apos;]</code></pre><p>NLTK:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> word_tokenize</span><br><span class="line"><span class="keyword">from</span> nltk <span class="keyword">import</span> data</span><br><span class="line">data.path.append(<span class="string">'/home/kesci/input/nltk_data3784/nltk_data'</span>)</span><br><span class="line">print(word_tokenize(text))</span><br></pre></td></tr></table></figure><pre><code>[&apos;Mr.&apos;, &apos;Chen&apos;, &apos;does&apos;, &quot;n&apos;t&quot;, &apos;agree&apos;, &apos;with&apos;, &apos;my&apos;, &apos;suggestion&apos;, &apos;.&apos;]</code></pre><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
      <category term="文本读入" scheme="http://yoursite.com/tags/%E6%96%87%E6%9C%AC%E8%AF%BB%E5%85%A5/"/>
    
      <category term="字符操作" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C/"/>
    
      <category term="分词" scheme="http://yoursite.com/tags/%E5%88%86%E8%AF%8D/"/>
    
      <category term="现有分词包" scheme="http://yoursite.com/tags/%E7%8E%B0%E6%9C%89%E5%88%86%E8%AF%8D%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Task1.3 多层感知机</title>
    <link href="http://yoursite.com/2020/02/14/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/02/14/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/</id>
    <published>2020-02-14T07:42:58.425Z</published>
    <updated>2020-02-15T14:32:06.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h1><ol><li>多层感知机的基本知识</li><li>使用多层感知机图像分类的从零开始的实现</li><li>使用pytorch的简洁实现</li></ol><h2 id="多层感知机的基本知识"><a href="#多层感知机的基本知识" class="headerlink" title="多层感知机的基本知识"></a>多层感知机的基本知识</h2><p>深度学习主要关注多层模型。在这里，我们将以多层感知机（multilayer perceptron，MLP）为例，介绍多层神经网络的概念。</p><h3 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h3><p>下图展示了一个多层感知机的神经网络图，它含有一个隐藏层，该层中有5个隐藏单元。</p><p><img src="https://cdn.kesci.com/upload/image/q5ho684jmh.png" alt="Image Name"></p><h3 id="表达公式"><a href="#表达公式" class="headerlink" title="表达公式"></a>表达公式</h3><p>具体来说，给定一个小批量样本$\boldsymbol{X} \in \mathbb{R}^{n \times d}$，其批量大小为$n$，输入个数为$d$。假设多层感知机只有一个隐藏层，其中隐藏单元个数为$h$。记隐藏层的输出（也称为隐藏层变量或隐藏变量）为$\boldsymbol{H}$，有$\boldsymbol{H} \in \mathbb{R}^{n \times h}$。因为隐藏层和输出层均是全连接层，可以设隐藏层的权重参数和偏差参数分别为$\boldsymbol{W}_h \in \mathbb{R}^{d \times h}$和 $\boldsymbol{b}_h \in \mathbb{R}^{1 \times h}$，输出层的权重和偏差参数分别为$\boldsymbol{W}_o \in \mathbb{R}^{h \times q}$和$\boldsymbol{b}_o \in \mathbb{R}^{1 \times q}$。</p><p>我们先来看一种含单隐藏层的多层感知机的设计。其输出$\boldsymbol{O} \in \mathbb{R}^{n \times q}$的计算为</p><p>$$<br>\begin{aligned} \boldsymbol{H} &amp;= \boldsymbol{X} \boldsymbol{W}_h + \boldsymbol{b}_h,\ \boldsymbol{O} &amp;= \boldsymbol{H} \boldsymbol{W}_o + \boldsymbol{b}_o, \end{aligned}<br>$$</p><p>也就是将隐藏层的输出直接作为输出层的输入。如果将以上两个式子联立起来，可以得到</p><p>$$<br>\boldsymbol{O} = (\boldsymbol{X} \boldsymbol{W}_h + \boldsymbol{b}_h)\boldsymbol{W}_o + \boldsymbol{b}_o = \boldsymbol{X} \boldsymbol{W}_h\boldsymbol{W}_o + \boldsymbol{b}_h \boldsymbol{W}_o + \boldsymbol{b}_o.<br>$$</p><p>从联立后的式子可以看出，虽然神经网络引入了隐藏层，却依然等价于一个单层神经网络：其中输出层权重参数为$\boldsymbol{W}_h\boldsymbol{W}_o$，偏差参数为$\boldsymbol{b}_h \boldsymbol{W}_o + \boldsymbol{b}_o$。不难发现，即便再添加更多的隐藏层，以上设计依然只能与仅含输出层的单层神经网络等价。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>上述问题的根源在于全连接层只是对数据做仿射变换（affine transformation），而多个仿射变换的叠加仍然是一个仿射变换。解决问题的一个方法是引入非线性变换，例如对隐藏变量使用按元素运算的非线性函数进行变换，然后再作为下一个全连接层的输入。这个非线性函数被称为激活函数（activation function）。</p><p>下面我们介绍几个常用的激活函数：</p><h4 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h4><p>ReLU（rectified linear unit）函数提供了一个很简单的非线性变换。给定元素$x$，该函数定义为</p><p>$$<br>\text{ReLU}(x) = \max(x, 0).<br>$$</p><p>可以看出，ReLU函数只保留正数元素，并将负数元素清零。为了直观地观察这一非线性变换，我们先定义一个绘图函数xyplot。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.3.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xyplot</span><span class="params">(x_vals, y_vals, name)</span>:</span></span><br><span class="line">    <span class="comment"># d2l.set_figsize(figsize=(5, 2.5))</span></span><br><span class="line">    plt.plot(x_vals.detach().numpy(), y_vals.detach().numpy()) <span class="comment"># 参数x_vals &amp; y_vals 不需要计算梯度</span></span><br><span class="line">    plt.xlabel(<span class="string">'x'</span>) </span><br><span class="line">    plt.ylabel(name + <span class="string">'(x)'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">-8.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x.relu()</span><br><span class="line">xyplot(x, y, <span class="string">'relu'</span>)</span><br></pre></td></tr></table></figure><img src="https://cdn.kesci.com/rt_upload/070825B6A382411DA5BD7D14E67E8D54/q5oe5b289s.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y.sum().backward() <span class="comment"># 构造标量计算梯度</span></span><br><span class="line">xyplot(x, x.grad, <span class="string">'grad of relu'</span>) <span class="comment"># relu函数的梯度图</span></span><br></pre></td></tr></table></figure><img src="https://cdn.kesci.com/rt_upload/BFB05150DBD1474D9A9ECCB9CDF1DD39/q5oe5bgivv.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print(x,y)</span></span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure><pre><code>tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,        0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1.,        1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,        1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,        1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,        1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])</code></pre><h4 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h4><p>sigmoid函数可以将元素的值变换到0和1之间：</p><p>$$<br>\text{sigmoid}(x) = \frac{1}{1 + \exp(-x)}.<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = x.sigmoid()</span><br><span class="line">xyplot(x, y, <span class="string">'sigmoid'</span>)</span><br></pre></td></tr></table></figure><img src="https://cdn.kesci.com/rt_upload/68FCB4E8142144458F13128B370D1C91/q5oe5ctfoa.png"><p>依据链式法则，sigmoid函数的导数</p><p>$$<br>\text{sigmoid}’(x) = \text{sigmoid}(x)\left(1-\text{sigmoid}(x)\right).<br>$$</p><p>下面绘制了sigmoid函数的导数。当输入为0时，sigmoid函数的导数达到最大值0.25；当输入越偏离0时，sigmoid函数的导数越接近0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y.sum().backward()</span><br><span class="line">xyplot(x, x.grad, <span class="string">'grad of sigmoid'</span>)</span><br></pre></td></tr></table></figure><img src="https://cdn.kesci.com/rt_upload/878C7B8823304F72860965E119A21412/q5oe5cbbzo.png"><h4 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h4><p>tanh（双曲正切）函数可以将元素的值变换到-1和1之间：</p><p>$$<br>\text{tanh}(x) = \frac{1 - \exp(-2x)}{1 + \exp(-2x)}.<br>$$</p><p>我们接着绘制tanh函数。当输入接近0时，tanh函数接近线性变换。虽然该函数的形状和sigmoid函数的形状很像，但tanh函数在坐标系的原点上对称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = x.tanh()</span><br><span class="line">xyplot(x, y, <span class="string">'tanh'</span>)</span><br></pre></td></tr></table></figure><img src="https://cdn.kesci.com/rt_upload/92D16076309F42169482834C0B6ABB24/q5oe5c1jlq.png"><p>依据链式法则，tanh函数的导数</p><p>$$<br>\text{tanh}’(x) = 1 - \text{tanh}^2(x).<br>$$</p><p>下面绘制了tanh函数的导数。当输入为0时，tanh函数的导数达到最大值1；当输入越偏离0时，tanh函数的导数越接近0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y.sum().backward()</span><br><span class="line">xyplot(x, x.grad, <span class="string">'grad of tanh'</span>)</span><br></pre></td></tr></table></figure><img src="https://cdn.kesci.com/rt_upload/CB16F4B33E664E14BCE8E52D8B37C47F/q5oe5cwaur.png"><h3 id="关于激活函数的选择"><a href="#关于激活函数的选择" class="headerlink" title="关于激活函数的选择"></a>关于激活函数的选择</h3><p>ReLu函数是一个通用的激活函数，目前在大多数情况下使用。但是，ReLU函数只能在隐藏层中使用。</p><p>用于分类器时，sigmoid函数及其组合通常效果更好。由于梯度消失问题，有时要避免使用sigmoid和tanh函数。</p><p>在神经网络层数较多的时候，最好使用ReLu函数，ReLu函数比较简单计算量少，而sigmoid和tanh函数计算量大很多。</p><p>在选择激活函数的时候可以先选用ReLu函数如果效果不理想可以尝试其他激活函数。</p><h3 id="多层感知机-1"><a href="#多层感知机-1" class="headerlink" title="多层感知机"></a>多层感知机</h3><p>多层感知机就是含有至少一个隐藏层的由全连接层组成的神经网络，且每个隐藏层的输出通过激活函数进行变换。多层感知机的层数和各隐藏层中隐藏单元个数都是超参数。以单隐藏层为例并沿用本节之前定义的符号，多层感知机按以下方式计算输出：</p><p>$$<br>\begin{aligned} \boldsymbol{H} &amp;= \phi(\boldsymbol{X} \boldsymbol{W}_h + \boldsymbol{b}_h),\ \boldsymbol{O} &amp;= \boldsymbol{H} \boldsymbol{W}_o + \boldsymbol{b}_o, \end{aligned}<br>$$</p><p>其中$\phi$表示激活函数。</p><h2 id="多层感知机从零开始的实现"><a href="#多层感知机从零开始的实现" class="headerlink" title="多层感知机从零开始的实现"></a>多层感知机从零开始的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.3.0</code></pre><h3 id="获取训练集"><a href="#获取训练集" class="headerlink" title="获取训练集"></a>获取训练集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size,root=<span class="string">'/home/kesci/input/FashionMNIST2065'</span>)</span><br></pre></td></tr></table></figure><h3 id="定义模型参数"><a href="#定义模型参数" class="headerlink" title="定义模型参数"></a>定义模型参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line"></span><br><span class="line">W1 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_inputs, num_hiddens)), dtype=torch.float)</span><br><span class="line">b1 = torch.zeros(num_hiddens, dtype=torch.float)</span><br><span class="line">W2 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_hiddens, num_outputs)), dtype=torch.float)</span><br><span class="line">b2 = torch.zeros(num_outputs, dtype=torch.float)</span><br><span class="line"></span><br><span class="line">params = [W1, b1, W2, b2]</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">    param.requires_grad_(requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="定义激活函数"><a href="#定义激活函数" class="headerlink" title="定义激活函数"></a>定义激活函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> torch.max(input=X, other=torch.tensor(<span class="number">0.0</span>))</span><br></pre></td></tr></table></figure><h3 id="定义网络"><a href="#定义网络" class="headerlink" title="定义网络"></a>定义网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span><span class="params">(X)</span>:</span></span><br><span class="line">    X = X.view((<span class="number">-1</span>, num_inputs))</span><br><span class="line">    H = relu(torch.matmul(X, W1) + b1)</span><br><span class="line">    <span class="keyword">return</span> torch.matmul(H, W2) + b2</span><br></pre></td></tr></table></figure><h3 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = torch.nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr = <span class="number">5</span>, <span class="number">100.0</span></span><br><span class="line"><span class="comment"># def train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size,</span></span><br><span class="line"><span class="comment">#               params=None, lr=None, optimizer=None):</span></span><br><span class="line"><span class="comment">#     for epoch in range(num_epochs):</span></span><br><span class="line"><span class="comment">#         train_l_sum, train_acc_sum, n = 0.0, 0.0, 0</span></span><br><span class="line"><span class="comment">#         for X, y in train_iter:</span></span><br><span class="line"><span class="comment">#             y_hat = net(X)</span></span><br><span class="line"><span class="comment">#             l = loss(y_hat, y).sum()</span></span><br><span class="line"><span class="comment">#             </span></span><br><span class="line"><span class="comment">#             # 梯度清零</span></span><br><span class="line"><span class="comment">#             if optimizer is not None:</span></span><br><span class="line"><span class="comment">#                 optimizer.zero_grad()</span></span><br><span class="line"><span class="comment">#             elif params is not None and params[0].grad is not None:</span></span><br><span class="line"><span class="comment">#                 for param in params:</span></span><br><span class="line"><span class="comment">#                     param.grad.data.zero_()</span></span><br><span class="line"><span class="comment">#            </span></span><br><span class="line"><span class="comment">#             l.backward()</span></span><br><span class="line"><span class="comment">#             if optimizer is None:</span></span><br><span class="line"><span class="comment">#                 d2l.sgd(params, lr, batch_size)</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 optimizer.step()  # “softmax回归的简洁实现”一节将用到</span></span><br><span class="line"><span class="comment">#             </span></span><br><span class="line"><span class="comment">#             </span></span><br><span class="line"><span class="comment">#             train_l_sum += l.item()</span></span><br><span class="line"><span class="comment">#             train_acc_sum += (y_hat.argmax(dim=1) == y).sum().item()</span></span><br><span class="line"><span class="comment">#             n += y.shape[0]</span></span><br><span class="line"><span class="comment">#         test_acc = evaluate_accuracy(test_iter, net)</span></span><br><span class="line"><span class="comment">#         print('epoch %d, loss %.4f, train acc %.3f, test acc %.3f'</span></span><br><span class="line"><span class="comment">#               % (epoch + 1, train_l_sum / n, train_acc_sum / n, test_acc))</span></span><br><span class="line"></span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, params, lr)</span><br></pre></td></tr></table></figure><pre><code>epoch 1, loss 0.0030, train acc 0.715, test acc 0.807epoch 2, loss 0.0019, train acc 0.822, test acc 0.791epoch 3, loss 0.0017, train acc 0.844, test acc 0.831epoch 4, loss 0.0015, train acc 0.857, test acc 0.811epoch 5, loss 0.0015, train acc 0.864, test acc 0.810</code></pre><h2 id="多层感知机pytorch实现"><a href="#多层感知机pytorch实现" class="headerlink" title="多层感知机pytorch实现"></a>多层感知机pytorch实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.3.0</code></pre><h3 id="初始化模型和各个参数"><a href="#初始化模型和各个参数" class="headerlink" title="初始化模型和各个参数"></a>初始化模型和各个参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">    </span><br><span class="line">net = nn.Sequential(</span><br><span class="line">        d2l.FlattenLayer(),</span><br><span class="line">        nn.Linear(num_inputs, num_hiddens),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Linear(num_hiddens, num_outputs), </span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> params <span class="keyword">in</span> net.parameters():</span><br><span class="line">    init.normal_(params, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size,root=<span class="string">'/home/kesci/input/FashionMNIST2065'</span>)</span><br><span class="line">loss = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">5</span></span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, <span class="literal">None</span>, <span class="literal">None</span>, optimizer)</span><br></pre></td></tr></table></figure><pre><code>epoch 1, loss 0.0031, train acc 0.700, test acc 0.742epoch 2, loss 0.0019, train acc 0.819, test acc 0.804epoch 3, loss 0.0017, train acc 0.841, test acc 0.827epoch 4, loss 0.0016, train acc 0.853, test acc 0.836epoch 5, loss 0.0015, train acc 0.862, test acc 0.788</code></pre><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
      <category term="多层感知机" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    
      <category term="隐藏层" scheme="http://yoursite.com/tags/%E9%9A%90%E8%97%8F%E5%B1%82/"/>
    
      <category term="激活函数" scheme="http://yoursite.com/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
      <category term="梯度" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6/"/>
    
      <category term="反向传播" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>Task1.2 softmax分类</title>
    <link href="http://yoursite.com/2020/02/14/Softmax%E4%B8%8E%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/02/14/Softmax%E4%B8%8E%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-02-14T07:36:58.801Z</published>
    <updated>2020-02-15T14:31:58.374Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="softmax和分类模型"><a href="#softmax和分类模型" class="headerlink" title="softmax和分类模型"></a>softmax和分类模型</h1><p>内容包含：</p><ol><li>softmax回归的基本概念</li><li>如何获取Fashion-MNIST数据集和读取数据</li><li>softmax回归模型的从零开始实现，实现一个对Fashion-MNIST训练集中的图像数据进行分类的模型</li><li>使用pytorch重新实现softmax回归模型</li></ol><h2 id="softmax的基本概念"><a href="#softmax的基本概念" class="headerlink" title="softmax的基本概念"></a>softmax的基本概念</h2><ul><li><p>分类问题<br>一个简单的图像分类问题，输入图像的高和宽均为2像素，色彩为灰度。<br>图像中的4像素分别记为$x_1, x_2, x_3, x_4$。<br>假设真实标签为狗、猫或者鸡，这些标签对应的离散值为$y_1, y_2, y_3$。<br>我们通常使用离散的数值来表示类别，例如$y_1=1, y_2=2, y_3=3$。</p></li><li><p>权重矢量<br>$$<br>\begin{aligned} o_1 &amp;= x_1 w_{11} + x_2 w_{21} + x_3 w_{31} + x_4 w_{41} + b_1 \end{aligned}<br>$$</p></li></ul><p>$$<br>\begin{aligned} o_2 &amp;= x_1 w_{12} + x_2 w_{22} + x_3 w_{32} + x_4 w_{42} + b_2 \end{aligned}<br>$$</p><p>$$<br>\begin{aligned} o_3 &amp;= x_1 w_{13} + x_2 w_{23} + x_3 w_{33} + x_4 w_{43} + b_3 \end{aligned}<br>$$<br>$o_1,o_2,o_3 $分别表示类别为1、2、3的概率</p><ul><li>神经网络图<br>下图用神经网络图描绘了上面的计算。softmax回归同线性回归一样，也是一个单层神经网络。由于每个输出$o_1, o_2, o_3$的计算都要依赖于所有的输入$x_1, x_2, x_3, x_4$，softmax回归的输出层也是一个全连接层。</li></ul><p><img src="https://cdn.kesci.com/upload/image/q5hmymezog.png" alt="Image Name"></p><p>$$<br>\begin{aligned}softmax回归是一个单层神经网络\end{aligned}<br>$$</p><p>既然分类问题需要得到离散的预测输出，一个简单的办法是将输出值$o_i$当作预测类别是$i$的置信度，并将值最大的输出所对应的类作为预测输出，即输出 $\underset{i}{\arg\max} o_i$。例如，如果$o_1,o_2,o_3$分别为$0.1,10,0.1$，由于$o_2$最大，那么预测类别为2，其代表猫。</p><ul><li>输出问题<br>直接使用输出层的输出有两个问题：<ol><li>一方面，由于输出层的输出值的范围不确定，我们难以直观上判断这些值的意义。例如，刚才举的例子中的输出值10表示“很置信”图像类别为猫，因为该输出值是其他两类的输出值的100倍。但如果$o_1=o_3=10^3$，那么输出值10却又表示图像类别为猫的概率很低。</li><li>另一方面，由于真实标签是离散值，这些离散值与不确定范围的输出值之间的误差难以衡量。</li></ol></li></ul><p>softmax运算符（softmax operator）解决了以上两个问题。它通过下式将输出值变换成值为正且和为1的概率分布：</p><p>$$<br>\hat{y}_1, \hat{y}_2, \hat{y}_3 = \text{softmax}(o_1, o_2, o_3)<br>$$</p><p>其中</p><p>$$<br>\hat{y}1 = \frac{ \exp(o_1)}{\sum_{i=1}^3 \exp(o_i)},\quad \hat{y}2 = \frac{ \exp(o_2)}{\sum_{i=1}^3 \exp(o_i)},\quad \hat{y}3 = \frac{ \exp(o_3)}{\sum_{i=1}^3 \exp(o_i)}.<br>$$</p><p>容易看出$\hat{y}_1 + \hat{y}_2 + \hat{y}_3 = 1$且$0 \leq \hat{y}_1, \hat{y}_2, \hat{y}_3 \leq 1$，因此$\hat{y}_1, \hat{y}_2, \hat{y}_3$是一个合法的概率分布。这时候，如果$\hat{y}_2=0.8$，不管$\hat{y}_1$和$\hat{y}_3$的值是多少，我们都知道图像类别为猫的概率是80%。此外，我们注意到</p><p>$$<br>\underset{i}{\arg\max} o_i = \underset{i}{\arg\max} \hat{y}_i<br>$$</p><p>因此softmax运算不改变预测类别输出。</p><ul><li>计算效率<ul><li>单样本矢量计算表达式<br>为了提高计算效率，我们可以将单样本分类通过矢量计算来表达。在上面的图像分类问题中，假设softmax回归的权重和偏差参数分别为</li></ul></li></ul><p>$$<br>\boldsymbol{W} = \begin{bmatrix} w_{11} &amp; w_{12} &amp; w_{13} \ w_{21} &amp; w_{22} &amp; w_{23} \ w_{31} &amp; w_{32} &amp; w_{33} \ w_{41} &amp; w_{42} &amp; w_{43} \end{bmatrix},\quad \boldsymbol{b} = \begin{bmatrix} b_1 &amp; b_2 &amp; b_3 \end{bmatrix},<br>$$</p><p>设高和宽分别为2个像素的图像样本$i$的特征为</p><p>$$<br>\boldsymbol{x}^{(i)} = \begin{bmatrix}x_1^{(i)} &amp; x_2^{(i)} &amp; x_3^{(i)} &amp; x_4^{(i)}\end{bmatrix},<br>$$</p><p>输出层的输出为</p><p>$$<br>\boldsymbol{o}^{(i)} = \begin{bmatrix}o_1^{(i)} &amp; o_2^{(i)} &amp; o_3^{(i)}\end{bmatrix},<br>$$</p><p>预测为狗、猫或鸡的概率分布为</p><p>$$<br>\boldsymbol{\hat{y}}^{(i)} = \begin{bmatrix}\hat{y}_1^{(i)} &amp; \hat{y}_2^{(i)} &amp; \hat{y}_3^{(i)}\end{bmatrix}.<br>$$</p><p>softmax回归对样本$i$分类的矢量计算表达式为</p><p>$$<br>\begin{aligned} \boldsymbol{o}^{(i)} &amp;= \boldsymbol{x}^{(i)} \boldsymbol{W} + \boldsymbol{b},\ \boldsymbol{\hat{y}}^{(i)} &amp;= \text{softmax}(\boldsymbol{o}^{(i)}). \end{aligned}<br>$$</p><ul><li>小批量矢量计算表达式<br>为了进一步提升计算效率，我们通常对小批量数据做矢量计算。广义上讲，给定一个小批量样本，其批量大小为$n$，输入个数（特征数）为$d$，输出个数（类别数）为$q$。设批量特征为$\boldsymbol{X} \in \mathbb{R}^{n \times d}$。假设softmax回归的权重和偏差参数分别为$\boldsymbol{W} \in \mathbb{R}^{d \times q}$和$\boldsymbol{b} \in \mathbb{R}^{1 \times q}$。softmax回归的矢量计算表达式为</li></ul><p>$$<br>\begin{aligned} \boldsymbol{O} &amp;= \boldsymbol{X} \boldsymbol{W} + \boldsymbol{b},\ \boldsymbol{\hat{Y}} &amp;= \text{softmax}(\boldsymbol{O}), \end{aligned}<br>$$</p><p>其中的加法运算使用了广播机制，$\boldsymbol{O}, \boldsymbol{\hat{Y}} \in \mathbb{R}^{n \times q}$且这两个矩阵的第$i$行分别为样本$i$的输出$\boldsymbol{o}^{(i)}$和概率分布$\boldsymbol{\hat{y}}^{(i)}$。</p><h2 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h2><p>对于样本$i$，我们构造向量$\boldsymbol{y}^{(i)}\in \mathbb{R}^{q}$ ，使其第$y^{(i)}$（样本$i$类别的离散数值）个元素为1，其余为0。这样我们的训练目标可以设为使预测概率分布$\boldsymbol{\hat y}^{(i)}$尽可能接近真实的标签概率分布$\boldsymbol{y}^{(i)}$。</p><ul><li>平方损失估计</li></ul><p>$$<br>\begin{aligned}Loss = |\boldsymbol{\hat y}^{(i)}-\boldsymbol{y}^{(i)}|^2/2\end{aligned}<br>$$</p><p>然而，想要预测分类结果正确，我们其实并不需要预测概率完全等于标签概率。例如，在图像分类的例子里，如果$y^{(i)}=3$，那么我们只需要$\hat{y}^{(i)}_3$比其他两个预测值$\hat{y}^{(i)}_1$和$\hat{y}^{(i)}_2$大就行了。即使$\hat{y}^{(i)}_3$值为0.6，不管其他两个预测值为多少，类别预测均正确。而平方损失则过于严格，例如$\hat y^{(i)}_1=\hat y^{(i)}_2=0.2$比$\hat y^{(i)}_1=0, \hat y^{(i)}_2=0.4$的损失要小很多，虽然两者都有同样正确的分类预测结果。</p><p>改善上述问题的一个方法是使用更适合衡量两个概率分布差异的测量函数。其中，交叉熵（cross entropy）是一个常用的衡量方法：</p><p>$$<br>H\left(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}\right ) = -\sum_{j=1}^q y_j^{(i)} \log \hat y_j^{(i)},<br>$$</p><p>其中带下标的$y_j^{(i)}$是向量$\boldsymbol y^{(i)}$中非0即1的元素，需要注意将它与样本$i$类别的离散数值，即不带下标的$y^{(i)}$区分。在上式中，我们知道向量$\boldsymbol y^{(i)}$中只有第$y^{(i)}$个元素$y^{(i)}{y^{(i)}}$为1，其余全为0，于是$H(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}) = -\log \hat y_{y^{(i)}}^{(i)}$。也就是说，交叉熵只关心对正确类别的预测概率，因为只要其值足够大，就可以确保分类结果正确。当然，遇到一个样本有多个标签时，例如图像里含有不止一个物体时，我们并不能做这一步简化。但即便对于这种情况，交叉熵同样只关心对图像中出现的物体类别的预测概率。</p><p>假设训练数据集的样本数为$n$，交叉熵损失函数定义为<br>$$<br>\ell(\boldsymbol{\Theta}) = \frac{1}{n} \sum_{i=1}^n H\left(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}\right ),<br>$$</p><p>其中$\boldsymbol{\Theta}$代表模型参数。同样地，如果每个样本只有一个标签，那么交叉熵损失可以简写成$\ell(\boldsymbol{\Theta}) = -(1/n) \sum_{i=1}^n \log \hat y_{y^{(i)}}^{(i)}$。从另一个角度来看，我们知道最小化$\ell(\boldsymbol{\Theta})$等价于最大化$\exp(-n\ell(\boldsymbol{\Theta}))=\prod_{i=1}^n \hat y_{y^{(i)}}^{(i)}$，即最小化交叉熵损失函数等价于最大化训练数据集所有标签类别的联合预测概率。</p><h2 id="模型训练和预测"><a href="#模型训练和预测" class="headerlink" title="模型训练和预测"></a>模型训练和预测</h2><p>在训练好softmax回归模型后，给定任一样本特征，就可以预测每个输出类别的概率。通常，我们把预测概率最大的类别作为输出类别。如果它与真实类别（标签）一致，说明这次预测是正确的。在3.6节的实验中，我们将使用准确率（accuracy）来评价模型的表现。它等于正确预测数量与总预测数量之比。</p><h1 id="获取Fashion-MNIST训练集和读取数据"><a href="#获取Fashion-MNIST训练集和读取数据" class="headerlink" title="获取Fashion-MNIST训练集和读取数据"></a>获取Fashion-MNIST训练集和读取数据</h1><p>在介绍softmax回归的实现前我们先引入一个多类图像分类数据集。它将在后面的章节中被多次使用，以方便我们观察比较算法之间在模型精度和计算效率上的区别。图像分类数据集中最常用的是手写数字识别数据集MNIST[1]。但大部分模型在MNIST上的分类精度都超过了95%。为了更直观地观察算法之间的差异，我们将使用一个图像内容更加复杂的数据集Fashion-MNIST[2]。</p><p>我这里我们会使用torchvision包，它是服务于PyTorch深度学习框架的，主要用来构建计算机视觉模型。torchvision主要由以下几部分构成：</p><ol><li>torchvision.datasets: 一些加载数据的函数及常用的数据集接口；</li><li>torchvision.models: 包含常用的模型结构（含预训练模型），例如AlexNet、VGG、ResNet等；</li><li>torchvision.transforms: 常用的图片变换，例如裁剪、旋转等；</li><li>torchvision.utils: 其他的一些有用的方法。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import needed package</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">print(torch.__version__)</span><br><span class="line">print(torchvision.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.3.00.4.1a0+d94043a</code></pre><h2 id="get-dataset"><a href="#get-dataset" class="headerlink" title="get dataset"></a>get dataset</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mnist_train = torchvision.datasets.FashionMNIST(root=<span class="string">'/home/kesci/input/FashionMNIST2065'</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transforms.ToTensor())</span><br><span class="line">mnist_test = torchvision.datasets.FashionMNIST(root=<span class="string">'/home/kesci/input/FashionMNIST2065'</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transforms.ToTensor())</span><br></pre></td></tr></table></figure><p>class torchvision.datasets.FashionMNIST(root, train=True, transform=None, target_transform=None, download=False)</p><ul><li>root（string）– 数据集的根目录，其中存放processed/training.pt和processed/test.pt文件。</li><li>train（bool, 可选）– 如果设置为True，从training.pt创建数据集，否则从test.pt创建。</li><li>download（bool, 可选）– 如果设置为True，从互联网下载数据并放到root文件夹下。如果root目录下已经存在数据，不会再次下载。</li><li>transform（可被调用 , 可选）– 一种函数或变换，输入PIL图片，返回变换之后的数据。如：transforms.RandomCrop。</li><li>target_transform（可被调用 , 可选）– 一种函数或变换，输入目标，进行变换。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show result </span></span><br><span class="line">print(type(mnist_train))</span><br><span class="line">print(len(mnist_train), len(mnist_test))</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;torchvision.datasets.mnist.FashionMNIST&apos;&gt;60000 10000</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们可以通过下标来访问任意一个样本</span></span><br><span class="line">feature, label = mnist_train[<span class="number">0</span>]</span><br><span class="line">print(feature.shape, label)  <span class="comment"># Channel x Height x Width</span></span><br></pre></td></tr></table></figure><pre><code>torch.Size([1, 28, 28]) 9</code></pre><p>如果不做变换输入的数据是图像，我们可以看一下图片的类型参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mnist_PIL = torchvision.datasets.FashionMNIST(root=<span class="string">'/home/kesci/input/FashionMNIST2065'</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>)</span><br><span class="line">PIL_feature, label = mnist_PIL[<span class="number">0</span>]</span><br><span class="line">print(PIL_feature)</span><br></pre></td></tr></table></figure><pre><code>&lt;PIL.Image.Image image mode=L size=28x28 at 0x7F3CC188CDD8&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本函数已保存在d2lzh包中方便以后使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fashion_mnist_labels</span><span class="params">(labels)</span>:</span></span><br><span class="line">    text_labels = [<span class="string">'t-shirt'</span>, <span class="string">'trouser'</span>, <span class="string">'pullover'</span>, <span class="string">'dress'</span>, <span class="string">'coat'</span>,</span><br><span class="line">                   <span class="string">'sandal'</span>, <span class="string">'shirt'</span>, <span class="string">'sneaker'</span>, <span class="string">'bag'</span>, <span class="string">'ankle boot'</span>]</span><br><span class="line">    <span class="keyword">return</span> [text_labels[int(i)] <span class="keyword">for</span> i <span class="keyword">in</span> labels]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_fashion_mnist</span><span class="params">(images, labels)</span>:</span></span><br><span class="line">    d2l.use_svg_display()</span><br><span class="line">    <span class="comment"># 这里的_表示我们忽略（不使用）的变量</span></span><br><span class="line">    _, figs = plt.subplots(<span class="number">1</span>, len(images), figsize=(<span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">    <span class="keyword">for</span> f, img, lbl <span class="keyword">in</span> zip(figs, images, labels):</span><br><span class="line">        f.imshow(img.view((<span class="number">28</span>, <span class="number">28</span>)).numpy())</span><br><span class="line">        f.set_title(lbl)</span><br><span class="line">        f.axes.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">        f.axes.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X, y = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    X.append(mnist_train[i][<span class="number">0</span>]) <span class="comment"># 将第i个feature加到X中</span></span><br><span class="line">    y.append(mnist_train[i][<span class="number">1</span>]) <span class="comment"># 将第i个label加到y中</span></span><br><span class="line">show_fashion_mnist(X, get_fashion_mnist_labels(y))</span><br></pre></td></tr></table></figure><img src="https://cdn.kesci.com/rt_upload/056F457B00454FFD81A3CB6AD966C508/q5ogbetrhl.svg"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">num_workers = <span class="number">4</span></span><br><span class="line">train_iter = torch.utils.data.DataLoader(mnist_train, batch_size=batch_size, shuffle=<span class="literal">True</span>, num_workers=num_workers)</span><br><span class="line">test_iter = torch.utils.data.DataLoader(mnist_test, batch_size=batch_size, shuffle=<span class="literal">False</span>, num_workers=num_workers)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">print(<span class="string">'%.2f sec'</span> % (time.time() - start))</span><br></pre></td></tr></table></figure><pre><code>4.65 sec</code></pre><h1 id="softmax从零开始的实现"><a href="#softmax从零开始的实现" class="headerlink" title="softmax从零开始的实现"></a>softmax从零开始的实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">print(torch.__version__)</span><br><span class="line">print(torchvision.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.3.00.4.1a0+d94043a</code></pre><h2 id="获取训练集数据和测试集数据"><a href="#获取训练集数据和测试集数据" class="headerlink" title="获取训练集数据和测试集数据"></a>获取训练集数据和测试集数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, root=<span class="string">'/home/kesci/input/FashionMNIST2065'</span>)</span><br></pre></td></tr></table></figure><h2 id="模型参数初始化"><a href="#模型参数初始化" class="headerlink" title="模型参数初始化"></a>模型参数初始化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num_inputs = <span class="number">784</span></span><br><span class="line">print(<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">W = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_inputs, num_outputs)), dtype=torch.float)</span><br><span class="line">b = torch.zeros(num_outputs, dtype=torch.float)</span><br></pre></td></tr></table></figure><pre><code>784</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W.requires_grad_(requires_grad=<span class="literal">True</span>)</span><br><span class="line">b.requires_grad_(requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><pre><code>tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], requires_grad=True)</code></pre><h2 id="对多维Tensor按维度操作"><a href="#对多维Tensor按维度操作" class="headerlink" title="对多维Tensor按维度操作"></a>对多维Tensor按维度操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">print(X.sum(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>))  <span class="comment"># dim为0，按照相同的列求和，并在结果中保留列特征</span></span><br><span class="line">print(X.sum(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>))  <span class="comment"># dim为1，按照相同的行求和，并在结果中保留行特征</span></span><br><span class="line">print(X.sum(dim=<span class="number">0</span>, keepdim=<span class="literal">False</span>)) <span class="comment"># dim为0，按照相同的列求和，不在结果中保留列特征</span></span><br><span class="line">print(X.sum(dim=<span class="number">1</span>, keepdim=<span class="literal">False</span>)) <span class="comment"># dim为1，按照相同的行求和，不在结果中保留行特征</span></span><br></pre></td></tr></table></figure><pre><code>tensor([[5, 7, 9]])tensor([[ 6],        [15]])tensor([5, 7, 9])tensor([ 6, 15])</code></pre><h2 id="定义softmax操作"><a href="#定义softmax操作" class="headerlink" title="定义softmax操作"></a>定义softmax操作</h2><p>$$<br>\hat{y}<em>j = \frac{ \exp(o_j)}{\sum</em>{i=1}^3 \exp(o_i)}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(X)</span>:</span></span><br><span class="line">    X_exp = X.exp()</span><br><span class="line">    partition = X_exp.sum(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># print("X size is ", X_exp.size())</span></span><br><span class="line">    <span class="comment"># print("partition size is ", partition, partition.size())</span></span><br><span class="line">    <span class="keyword">return</span> X_exp / partition  <span class="comment"># 这里应用了广播机制</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand((<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">X_prob = softmax(X)</span><br><span class="line">print(X_prob, <span class="string">'\n'</span>, X_prob.sum(dim=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[0.1901, 0.2993, 0.1524, 0.1307, 0.2275],        [0.2043, 0.1929, 0.2544, 0.1523, 0.1962]])  tensor([1., 1.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(X)</span>:</span></span><br><span class="line">    X_exp = X.exp()</span><br><span class="line">    partition = X_exp.sum(dim=<span class="number">0</span>, keepdims = <span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># print("X size is ", X_exp.size())</span></span><br><span class="line">    <span class="comment"># print("partition size is ", partition, partition.size())</span></span><br><span class="line">    <span class="keyword">return</span> X_exp / partition  <span class="comment"># 这里应用了广播机制</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orig = torch.tensor([<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>], dtype = torch.float64)</span><br><span class="line">softmax(orig)</span><br></pre></td></tr></table></figure><pre><code>tensor([0.0900, 0.2447, 0.6652], dtype=torch.float64)</code></pre><h2 id="softmax回归模型"><a href="#softmax回归模型" class="headerlink" title="softmax回归模型"></a>softmax回归模型</h2><p>$$<br>\begin{aligned} \boldsymbol{o}^{(i)} &amp;= \boldsymbol{x}^{(i)} \boldsymbol{W} + \boldsymbol{b},\ \boldsymbol{\hat{y}}^{(i)} &amp;= \text{softmax}(\boldsymbol{o}^{(i)}). \end{aligned}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> softmax(torch.mm(X.view((<span class="number">-1</span>, num_inputs)), W) + b)</span><br></pre></td></tr></table></figure><h2 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><p>$$<br>H\left(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}\right ) = -\sum_{j=1}^q y_j^{(i)} \log \hat y_j^{(i)},<br>$$</p><p>$$<br>\ell(\boldsymbol{\Theta}) = \frac{1}{n} \sum_{i=1}^n H\left(\boldsymbol y^{(i)}, \boldsymbol {\hat y}^{(i)}\right ),<br>$$</p><p>$$<br>\ell(\boldsymbol{\Theta}) = -(1/n) \sum_{i=1}^n \log \hat y_{y^{(i)}}^{(i)}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_hat = torch.tensor([[<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.6</span>], [<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.5</span>]])</span><br><span class="line">y = torch.LongTensor([<span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">y_hat.gather(<span class="number">1</span>, y.view(<span class="number">-1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[0.1000],        [0.5000]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span><span class="params">(y_hat, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> - torch.log(y_hat.gather(<span class="number">1</span>, y.view(<span class="number">-1</span>, <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><h2 id="定义准确率"><a href="#定义准确率" class="headerlink" title="定义准确率"></a>定义准确率</h2><p>我们模型训练完了进行模型预测的时候，会用到我们这里定义的准确率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy</span><span class="params">(y_hat, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat.argmax(dim=<span class="number">1</span>) == y).float().mean().item()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(accuracy(y_hat, y))</span><br></pre></td></tr></table></figure><pre><code>0.5</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本函数已保存在d2lzh_pytorch包中方便以后使用。该函数将被逐步改进：它的完整实现将在“图像增广”一节中描述</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy</span><span class="params">(data_iter, net)</span>:</span></span><br><span class="line">    acc_sum, n = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        acc_sum += (net(X).argmax(dim=<span class="number">1</span>) == y).float().sum().item()</span><br><span class="line">        n += y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> acc_sum / n</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(evaluate_accuracy(test_iter, net))</span><br></pre></td></tr></table></figure><pre><code>0.1005</code></pre><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr = <span class="number">5</span>, <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本函数已保存在d2lzh_pytorch包中方便以后使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_ch3</span><span class="params">(net, train_iter, test_iter, loss, num_epochs, batch_size,</span></span></span><br><span class="line"><span class="function"><span class="params">              params=None, lr=None, optimizer=None)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        train_l_sum, train_acc_sum, n = <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            y_hat = net(X)</span><br><span class="line">            l = loss(y_hat, y).sum()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 梯度清零</span></span><br><span class="line">            <span class="keyword">if</span> optimizer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                optimizer.zero_grad()</span><br><span class="line">            <span class="keyword">elif</span> params <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> params[<span class="number">0</span>].grad <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">                    param.grad.data.zero_()</span><br><span class="line">            </span><br><span class="line">            l.backward()</span><br><span class="line">            <span class="keyword">if</span> optimizer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                d2l.sgd(params, lr, batch_size)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                optimizer.step() </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            train_l_sum += l.item()</span><br><span class="line">            train_acc_sum += (y_hat.argmax(dim=<span class="number">1</span>) == y).sum().item()</span><br><span class="line">            n += y.shape[<span class="number">0</span>]</span><br><span class="line">        test_acc = evaluate_accuracy(test_iter, net)</span><br><span class="line">        print(<span class="string">'epoch %d, loss %.4f, train acc %.3f, test acc %.3f'</span></span><br><span class="line">              % (epoch + <span class="number">1</span>, train_l_sum / n, train_acc_sum / n, test_acc))</span><br><span class="line"></span><br><span class="line">train_ch3(net, train_iter, test_iter, cross_entropy, num_epochs, batch_size, [W, b], lr)</span><br></pre></td></tr></table></figure><pre><code>epoch 1, loss 4.1183, train acc 0.771, test acc 0.793epoch 2, loss 3.9556, train acc 0.812, test acc 0.808epoch 3, loss 3.9205, train acc 0.823, test acc 0.815epoch 4, loss 3.9033, train acc 0.829, test acc 0.818epoch 5, loss 3.8915, train acc 0.833, test acc 0.820</code></pre><h2 id="模型预测"><a href="#模型预测" class="headerlink" title="模型预测"></a>模型预测</h2><p>现在我们的模型训练完了，可以进行一下预测，我们的这个模型训练的到底准确不准确。<br>现在就可以演示如何对图像进行分类了。给定一系列图像（第三行图像输出），我们比较一下它们的真实标签（第一行文本输出）和模型预测结果（第二行文本输出）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X, y = iter(test_iter).next()</span><br><span class="line"></span><br><span class="line">true_labels = d2l.get_fashion_mnist_labels(y.numpy())</span><br><span class="line">pred_labels = d2l.get_fashion_mnist_labels(net(X).argmax(dim=<span class="number">1</span>).numpy())</span><br><span class="line">titles = [true + <span class="string">'\n'</span> + pred <span class="keyword">for</span> true, pred <span class="keyword">in</span> zip(true_labels, pred_labels)]</span><br><span class="line"></span><br><span class="line">d2l.show_fashion_mnist(X[<span class="number">0</span>:<span class="number">9</span>], titles[<span class="number">0</span>:<span class="number">9</span>])</span><br></pre></td></tr></table></figure><img src="https://cdn.kesci.com/rt_upload/1DA8927186304BEBA2B3DCC4A9E027DD/q5ogcp4p0b.svg"><h1 id="softmax的简洁实现"><a href="#softmax的简洁实现" class="headerlink" title="softmax的简洁实现"></a>softmax的简洁实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载各种包或者模块</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/home/kesci/input"</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh1981 <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.3.0</code></pre><h2 id="初始化参数和获取数据"><a href="#初始化参数和获取数据" class="headerlink" title="初始化参数和获取数据"></a>初始化参数和获取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, root=<span class="string">'/home/kesci/input/FashionMNIST2065'</span>)</span><br></pre></td></tr></table></figure><h2 id="定义网络模型"><a href="#定义网络模型" class="headerlink" title="定义网络模型"></a>定义网络模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">num_inputs = <span class="number">784</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_inputs, num_outputs)</span>:</span></span><br><span class="line">        super(LinearNet, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(num_inputs, num_outputs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span> <span class="comment"># x 的形状: (batch, 1, 28, 28)</span></span><br><span class="line">        y = self.linear(x.view(x.shape[<span class="number">0</span>], <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    </span><br><span class="line"><span class="comment"># net = LinearNet(num_inputs, num_outputs)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlattenLayer</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(FlattenLayer, self).__init__()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span> <span class="comment"># x 的形状: (batch, *, *, ...)</span></span><br><span class="line">        <span class="keyword">return</span> x.view(x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">net = nn.Sequential(</span><br><span class="line">        <span class="comment"># FlattenLayer(),</span></span><br><span class="line">        <span class="comment"># LinearNet(num_inputs, num_outputs) </span></span><br><span class="line">        OrderedDict([</span><br><span class="line">           (<span class="string">'flatten'</span>, FlattenLayer()),</span><br><span class="line">           (<span class="string">'linear'</span>, nn.Linear(num_inputs, num_outputs))]) <span class="comment"># 或者写成我们自己定义的 LinearNet(num_inputs, num_outputs) 也可以</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h2 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init.normal_(net.linear.weight, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line">init.constant_(net.linear.bias, val=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><pre><code>Parameter containing:tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], requires_grad=True)</code></pre><h2 id="定义损失函数-1"><a href="#定义损失函数-1" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss() <span class="comment"># 下面是他的函数原型</span></span><br><span class="line"><span class="comment"># class torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean')</span></span><br></pre></td></tr></table></figure><h2 id="定义优化函数"><a href="#定义优化函数" class="headerlink" title="定义优化函数"></a>定义优化函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>) <span class="comment"># 下面是函数原型</span></span><br><span class="line"><span class="comment"># class torch.optim.SGD(params, lr=, momentum=0, dampening=0, weight_decay=0, nesterov=False)</span></span><br></pre></td></tr></table></figure><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">5</span></span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, <span class="literal">None</span>, <span class="literal">None</span>, optimizer)</span><br></pre></td></tr></table></figure><pre><code>epoch 1, loss 0.0031, train acc 0.749, test acc 0.782epoch 2, loss 0.0022, train acc 0.812, test acc 0.790epoch 3, loss 0.0021, train acc 0.826, test acc 0.819epoch 4, loss 0.0020, train acc 0.832, test acc 0.824epoch 5, loss 0.0019, train acc 0.836, test acc 0.826</code></pre><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
      <category term="softmax" scheme="http://yoursite.com/tags/softmax/"/>
    
      <category term="分类问题" scheme="http://yoursite.com/tags/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    
      <category term="交叉熵损失函数" scheme="http://yoursite.com/tags/%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    
      <category term="数据集的下载与读取" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E8%AF%BB%E5%8F%96/"/>
    
      <category term="多维tensor的操作" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BB%B4tensor%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Task1.1 线性回归</title>
    <link href="http://yoursite.com/2020/02/13/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/02/13/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</id>
    <published>2020-02-13T04:31:07.454Z</published>
    <updated>2020-02-15T14:31:51.549Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>主要内容包括：</p><ol><li>线性回归的基本要素</li><li>线性回归模型从零开始的实现</li><li>线性回归模型使用pytorch的简洁实现</li></ol><h2 id="线性回归的基本要素"><a href="#线性回归的基本要素" class="headerlink" title="线性回归的基本要素"></a>线性回归的基本要素</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>为了简单起见，这里我们假设价格只取决于房屋状况的两个因素，即面积（平方米）和房龄（年）。接下来我们希望探索价格与这两个因素的具体关系。线性回归假设输出与各个输入之间是线性关系:</p><p>$$<br>\mathrm{price} = w_{\mathrm{area}} \cdot \mathrm{area} + w_{\mathrm{age}} \cdot \mathrm{age} + b<br>$$<br>模型学习的即为$ω$(权重)和$b$(偏差)。</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>我们通常收集一系列的真实数据，例如多栋房屋的真实售出价格和它们对应的面积和房龄。我们希望在这个数据上面寻找模型参数来使模型的预测价格与真实价格的误差最小。在机器学习术语里，该数据集被称为训练数据集（training data set）或训练集（training set），一栋房屋被称为一个样本（sample），其真实售出价格叫作标签（label），用来预测标签的两个因素叫作特征（feature）。特征用来表征样本的特点。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>在模型训练中，我们需要衡量价格预测值与真实值之间的误差。通常我们会选取一个非负数作为误差，且数值越小表示误差越小。一个常用的选择是平方函数，即我们通常说的最小均方误差。它在评估索引为 $i$ 的样本误差的表达式为</p><p>$$<br>l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2,<br>$$</p><p>$$<br>L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.<br>$$</p><h3 id="优化函数-随机梯度下降"><a href="#优化函数-随机梯度下降" class="headerlink" title="优化函数 - 随机梯度下降"></a>优化函数 - 随机梯度下降</h3><p>当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫作解析解（analytical solution）。本节使用的线性回归和平方误差刚好属于这个范畴。然而，大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫作数值解（numerical solution）。</p><p>在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent）在深度学习中被广泛使用。它的算法很简单：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch）$\mathcal{B}$，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。</p><p>$$<br>(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b)<br>$$</p><p>学习率: $\eta$代表在每次优化中，能够学习的步长的大小<br>批量大小: $\mathcal{B}$是小批量计算中的批量大小batch size</p><p>总结一下，优化函数的有以下两个步骤：</p><ul><li>(i)初始化模型参数，一般来说使用随机初始化；</li><li>(ii)我们在数据上迭代多次，通过在负梯度方向移动参数来更新每个参数。</li></ul><h2 id="矢量计算"><a href="#矢量计算" class="headerlink" title="矢量计算"></a>矢量计算</h2><p>在模型训练或预测时，我们常常会同时处理多个数据样本并用到矢量计算。在介绍线性回归的矢量计算表达式之前，让我们先考虑对两个向量相加的两种方法。</p><ol><li>向量相加的一种方法是，将这两个向量按元素逐一做标量加法。</li><li>向量相加的另一种方法是，将这两个向量直接做矢量加法。</li></ol><p><strong>note</strong>: 利用torch生成向量，参考文档: <a href="https://pytorch.org/docs/stable/torch.html" target="_blank" rel="noopener">torch document</a>, <a href="https://pytorch-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">pytorch 中文文档</a>,利用torch.Size( )查看torch向量的维度,参考文档: <a href="https://pytorch.org/docs/stable/tensors.html?highlight=size#torch.Tensor.size" target="_blank" rel="noopener">torch.Tensor.size</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化两个 1000 * 1 维的变量a, b,且a, b中包含的元素全为1</span></span><br><span class="line">n = <span class="number">1000</span></span><br><span class="line">a = torch.ones(n)</span><br><span class="line">b = torch.ones(n)</span><br><span class="line"><span class="comment"># print(a,b)</span></span><br><span class="line">print(a.size(), b.size())</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">torch</span><span class="selector-class">.Size</span>(<span class="selector-attr">[1000]</span>) <span class="selector-tag">torch</span><span class="selector-class">.Size</span>(<span class="selector-attr">[1000]</span>)</span><br></pre></td></tr></table></figure><p>定义一个计时类Timer测量程序运行时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define a timer class to record time</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""记录不同的时刻."""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="comment"># 初始化实例变量，定义了两个属性times &amp; start</span></span><br><span class="line">        self.times = []  <span class="comment"># 空元组</span></span><br><span class="line">        self.start()  <span class="comment"># 函数</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="comment"># 计时开始</span></span><br><span class="line">        self.start_time = time.time()  <span class="comment"># 返回当前时间的时间戳，以1970纪元为起点，单位维秒，浮点型 </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 计时结束，记录程序耗时</span></span><br><span class="line">        self.times.append(time.time() - self.start_time) <span class="comment"># 元组中加入程序耗时</span></span><br><span class="line">        <span class="keyword">return</span> self.times[<span class="number">-1</span>] <span class="comment"># 函数返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avg</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 计算并返回每次循环的平均耗时</span></span><br><span class="line">        <span class="keyword">return</span> sum(self.times)/len(self.times)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回值： 所有记录下来的时间</span></span><br><span class="line">        <span class="keyword">return</span> sum(self.times)</span><br></pre></td></tr></table></figure><p>现在我们可以来测试了。首先将两个向量使用for循环按元素逐一做标量加法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timer = Timer() <span class="comment"># 将Timer实例化，实例化：定义了一个“某班学生类”，实例化：分析具体的某一个学生的特征,此时的timer也有两个属性：times &amp; start</span></span><br><span class="line">c = torch.zeros(n) <span class="comment"># 初始化一个 1000 * 1 零向量 c</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    c[i] = a[i] + b[i] </span><br><span class="line"><span class="string">'%.5f sec'</span> % timer.stop() <span class="comment"># 调用stop()函数，打印程序耗时</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'0.<span class="number">0166</span>9 sec'</span><br></pre></td></tr></table></figure><p>另外是使用torch来将两个向量直接做矢量加法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer.start() <span class="comment"># 计时开始</span></span><br><span class="line">d = a + b <span class="comment"># 使用torch直接做矢量加法</span></span><br><span class="line"><span class="string">'%.5f sec'</span> % timer.stop() <span class="comment">#计时结束，打印程序运行耗时</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'0.<span class="number">0010</span>0 sec'</span><br></pre></td></tr></table></figure><p>结果很明显,后者比前者运算速度更快。因此，我们应该尽可能采用<strong>矢量计算</strong>，以提升计算效率。</p><h2 id="线性回归模型从零开始的实现"><a href="#线性回归模型从零开始的实现" class="headerlink" title="线性回归模型从零开始的实现"></a>线性回归模型从零开始的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import packages and modules</span></span><br><span class="line"><span class="comment"># 魔法函数，内嵌绘图，可以省略掉plt.show()这一步</span></span><br><span class="line">%matplotlib inline  </span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(torch.__version__) <span class="comment"># 打印当前安装torch版本号</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.3</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h3 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h3><p>使用线性模型来生成数据集，生成一个1000个样本的数据集，下面是用来生成数据的线性关系：</p><p>$$<br>\mathrm{price} = w_{\mathrm{area}} \cdot \mathrm{area} + w_{\mathrm{age}} \cdot \mathrm{age} + b<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置输入特征参数，两个特征</span></span><br><span class="line">num_inputs = <span class="number">2</span></span><br><span class="line"><span class="comment"># 设置样本数</span></span><br><span class="line">num_examples = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置真实的权重和偏差值，用来生成对应的标签</span></span><br><span class="line">true_w = [<span class="number">2</span>, <span class="number">-3.4</span>] <span class="comment"># [面积, 房龄】</span></span><br><span class="line">true_b = <span class="number">4.2</span> <span class="comment"># [偏差]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机矢量，维度： 1000 * 2， 32位浮点型 </span></span><br><span class="line">features = torch.randn(num_examples, num_inputs,</span><br><span class="line">                      dtype=torch.float32) </span><br><span class="line">labels = true_w[<span class="number">0</span>] * features[:, <span class="number">0</span>] + true_w[<span class="number">1</span>] * features[:, <span class="number">1</span>] + true_b <span class="comment"># 严格线性意义上的标签值</span></span><br><span class="line">labels += torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=labels.size()),</span><br><span class="line">                       dtype=torch.float32) <span class="comment"># 加一个正态分布随机生成的偏差</span></span><br></pre></td></tr></table></figure><h3 id="使用图像来展示生成的数据"><a href="#使用图像来展示生成的数据" class="headerlink" title="使用图像来展示生成的数据"></a>使用图像来展示生成的数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_svg_display</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 定义矢量图显示函数</span></span><br><span class="line">    display.set_matplotlib_formats(<span class="string">'svg'</span>) <span class="comment"># 规定图片格式 'svg'</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_figsize</span><span class="params">(figsize = <span class="params">(<span class="number">3.5</span>, <span class="number">2.5</span>)</span>)</span>:</span></span><br><span class="line">    use_svg_display()</span><br><span class="line">    <span class="comment"># 图片大小 长 * 宽 = 3.5 * 2.5</span></span><br><span class="line">    plt.rcParams[<span class="string">'figure.figsize'</span>] = figsize <span class="comment"># 显示图像的最大范围</span></span><br><span class="line">    </span><br><span class="line">set_figsize() </span><br><span class="line">plt.scatter(features[:, <span class="number">1</span>].numpy(), labels.numpy(), <span class="number">1</span>); <span class="comment"># 绘制数据分布散点图，横轴为某一个特征值，纵轴为生成的标签值</span></span><br></pre></td></tr></table></figure><p>![svg](E:/deeplearning_hand/post/线性回归 (2)/output_16_0.svg)</p><h3 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter</span><span class="params">(batch_size, features, labels)</span>:</span></span><br><span class="line">    num_examples = len(features) </span><br><span class="line">    indices = list(range(num_examples)) <span class="comment"># [0,...,999]</span></span><br><span class="line">    random.shuffle(indices)  <span class="comment"># random read 10 samples</span></span><br><span class="line">    <span class="comment"># 每batch_size取一个样本，如果最后一个index大于999就取999</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, num_examples, batch_size): </span><br><span class="line">        j = torch.LongTensor(indices[i: min(i + batch_size, num_examples)]) <span class="comment"># the last time may be not enough for a whole batch</span></span><br><span class="line">        <span class="keyword">yield</span>  features.index_select(<span class="number">0</span>, j), labels.index_select(<span class="number">0</span>, j)</span><br></pre></td></tr></table></figure><p>yield 函数:<br>返回前先存在生成器g (generator)，此时需要返回的没有值，需要调用next()函数才能显示，下一次循环才return之前的值。</p><p>参考: <a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856" target="_blank" rel="noopener">CSDN Blog</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">    print(X, <span class="string">'\n'</span>, y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">0.1194</span>, <span class="number">-0.7470</span>],</span><br><span class="line">        [ <span class="number">0.4794</span>, <span class="number">-0.0793</span>],</span><br><span class="line">        [ <span class="number">0.5372</span>, <span class="number">-1.9226</span>],</span><br><span class="line">        [<span class="number">-0.2019</span>, <span class="number">-0.0378</span>],</span><br><span class="line">        [ <span class="number">0.9517</span>, <span class="number">-0.5550</span>],</span><br><span class="line">        [ <span class="number">0.1533</span>, <span class="number">-0.1862</span>],</span><br><span class="line">        [<span class="number">-0.3551</span>, <span class="number">-0.3219</span>],</span><br><span class="line">        [<span class="number">-1.1818</span>, <span class="number">-1.3702</span>],</span><br><span class="line">        [<span class="number">-1.1900</span>,  <span class="number">0.6628</span>],</span><br><span class="line">        [ <span class="number">0.3310</span>, <span class="number">-2.5353</span>]]) </span><br><span class="line"> tensor([ <span class="number">6.9595</span>,  <span class="number">5.4276</span>, <span class="number">11.8052</span>,  <span class="number">3.9242</span>,  <span class="number">7.9828</span>,  <span class="number">5.1330</span>,  <span class="number">4.5997</span>,  <span class="number">6.4896</span>,</span><br><span class="line">        <span class="number">-0.4190</span>, <span class="number">13.4675</span>])</span><br></pre></td></tr></table></figure><p>上面的cell注释break，页面 —&gt; 匹诺曹的鼻子</p><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_inputs, <span class="number">1</span>)), dtype=torch.float32) <span class="comment"># 步长0.01</span></span><br><span class="line">b = torch.zeros(<span class="number">1</span>, dtype=torch.float32) <span class="comment"># 初始化为0</span></span><br><span class="line"></span><br><span class="line">w.requires_grad_(requires_grad = <span class="literal">True</span>) <span class="comment"># 梯度附加</span></span><br><span class="line">b.requires_grad_(requires_grad = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([0.], <span class="attribute">requires_grad</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>pytorch autograd <a href="https://zhuanlan.zhihu.com/p/29904755" target="_blank" rel="noopener">参考网页</a></p><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>定义用来训练参数的训练模型：</p><p>$$<br>\mathrm{price} = w_{\mathrm{area}} \cdot \mathrm{area} + w_{\mathrm{age}} \cdot \mathrm{age} + b<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linreg</span><span class="params">(X, w, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> torch.mm(X, w) + b</span><br></pre></td></tr></table></figure><h3 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><p>我们使用的是均方误差损失函数：<br>$$<br>l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2,<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_loss</span><span class="params">(y_hat, y)</span>:</span> </span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.view(y_hat.size())) ** <span class="number">2</span> / <span class="number">2</span> <span class="comment"># view用法类似于resize</span></span><br></pre></td></tr></table></figure><h3 id="定义优化函数"><a href="#定义优化函数" class="headerlink" title="定义优化函数"></a>定义优化函数</h3><p>在这里优化函数使用的是小批量随机梯度下降：</p><p>$$<br>(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b)<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd</span><span class="params">(params, lr, batch_size)</span>:</span> </span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.data -= lr * param.grad / batch_size <span class="comment"># ues .data to operate param without gradient track</span></span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>当数据集、模型、损失函数和优化函数定义完了之后就可来准备进行模型的训练了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># super parameters init</span></span><br><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># training</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):  <span class="comment"># training repeats num_epochs times</span></span><br><span class="line">    <span class="comment"># in each epoch, all the samples in dataset will be used once</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># X is the feature and y is the label of a batch sample</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y).sum()  </span><br><span class="line">        <span class="comment"># calculate the gradient of batch sample loss </span></span><br><span class="line">        l.backward()  </span><br><span class="line">        <span class="comment"># using small batch random gradient descent to iter model parameters</span></span><br><span class="line">        sgd([w, b], lr, batch_size)  </span><br><span class="line">        <span class="comment"># reset parameter gradient 梯度清零</span></span><br><span class="line">        w.grad.data.zero_() </span><br><span class="line">        b.grad.data.zero_()</span><br><span class="line">    train_l = loss(net(features, w, b), labels)</span><br><span class="line">    print(<span class="string">'epoch %d, loss %f'</span> % (epoch + <span class="number">1</span>, train_l.mean().item()))</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoch <span class="number">1</span>, loss <span class="number">0.044235</span></span><br><span class="line">epoch <span class="number">2</span>, loss <span class="number">0.000185</span></span><br><span class="line">epoch <span class="number">3</span>, loss <span class="number">0.000053</span></span><br><span class="line">epoch <span class="number">4</span>, loss <span class="number">0.000052</span></span><br><span class="line">epoch <span class="number">5</span>, loss <span class="number">0.000052</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w, true_w, b, true_b</span><br></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">tensor</span>([[ <span class="number">2.0005</span>],</span><br><span class="line">         [<span class="name">-3.3992</span>]], requires_grad=True),</span><br><span class="line"> [<span class="name">2</span>, <span class="number">-3.4</span>],</span><br><span class="line"> tensor([<span class="name">4.1997</span>], requires_grad=True),</span><br><span class="line"> <span class="number">4.2</span>)</span><br></pre></td></tr></table></figure><h2 id="线性回归模型使用pytorch的简洁实现"><a href="#线性回归模型使用pytorch的简洁实现" class="headerlink" title="线性回归模型使用pytorch的简洁实现"></a>线性回归模型使用pytorch的简洁实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">torch.manual_seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(torch.__version__)</span><br><span class="line">torch.set_default_tensor_type(<span class="string">'torch.FloatTensor'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.3</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h3 id="生成数据集-1"><a href="#生成数据集-1" class="headerlink" title="生成数据集"></a>生成数据集</h3><p>在这里生成数据集跟从零开始的实现中是完全一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_inputs = <span class="number">2</span></span><br><span class="line">num_examples = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">true_w = [<span class="number">2</span>, <span class="number">-3.4</span>]</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line"></span><br><span class="line">features = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, num_inputs)), dtype=torch.float)</span><br><span class="line">labels = true_w[<span class="number">0</span>] * features[:, <span class="number">0</span>] + true_w[<span class="number">1</span>] * features[:, <span class="number">1</span>] + true_b</span><br><span class="line">labels += torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=labels.size()), dtype=torch.float)</span><br></pre></td></tr></table></figure><h3 id="读取数据集-1"><a href="#读取数据集-1" class="headerlink" title="读取数据集"></a>读取数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># combine featues and labels of dataset</span></span><br><span class="line">dataset = Data.TensorDataset(features, labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># put dataset into DataLoader</span></span><br><span class="line">data_iter = Data.DataLoader(</span><br><span class="line">    dataset=dataset,            <span class="comment"># torch TensorDataset format</span></span><br><span class="line">    batch_size=batch_size,      <span class="comment"># mini batch size</span></span><br><span class="line">    shuffle=<span class="literal">True</span>,               <span class="comment"># whether shuffle the data or not</span></span><br><span class="line">    num_workers=<span class="number">2</span>,              <span class="comment"># read data in multithreading</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">    print(X, <span class="string">'\n'</span>, y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">1.9411</span>, <span class="number">-1.2459</span>],</span><br><span class="line">        [ <span class="number">1.9920</span>,  <span class="number">0.2507</span>],</span><br><span class="line">        [<span class="number">-0.3322</span>,  <span class="number">0.1014</span>],</span><br><span class="line">        [<span class="number">-0.0793</span>, <span class="number">-0.0783</span>],</span><br><span class="line">        [<span class="number">-0.9001</span>,  <span class="number">1.1250</span>],</span><br><span class="line">        [ <span class="number">0.7180</span>, <span class="number">-0.0880</span>],</span><br><span class="line">        [ <span class="number">0.6308</span>, <span class="number">-1.4426</span>],</span><br><span class="line">        [<span class="number">-0.9646</span>, <span class="number">-0.1066</span>],</span><br><span class="line">        [<span class="number">-0.1680</span>,  <span class="number">2.4215</span>],</span><br><span class="line">        [ <span class="number">0.7460</span>, <span class="number">-0.2143</span>]]) </span><br><span class="line"> tensor([<span class="number">12.3139</span>,  <span class="number">7.3377</span>,  <span class="number">3.1872</span>,  <span class="number">4.2995</span>, <span class="number">-1.4368</span>,  <span class="number">5.9282</span>, <span class="number">10.3540</span>,  <span class="number">2.6203</span>,</span><br><span class="line">        <span class="number">-4.3579</span>,  <span class="number">6.4115</span>])</span><br></pre></td></tr></table></figure><h3 id="定义模型-1"><a href="#定义模型-1" class="headerlink" title="定义模型"></a>定义模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_feature)</span>:</span></span><br><span class="line">        super(LinearNet, self).__init__()      <span class="comment"># call father function to init </span></span><br><span class="line">        self.linear = nn.Linear(n_feature, <span class="number">1</span>)  <span class="comment"># function prototype: `torch.nn.Linear(in_features, out_features, bias=True)` 一个隐藏层的线性回归nn模型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        y = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    </span><br><span class="line">net = LinearNet(num_inputs)</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinearNet(</span><br><span class="line">  (linear): Linear(<span class="attribute">in_features</span>=2, <span class="attribute">out_features</span>=1, <span class="attribute">bias</span>=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3 ways to init a multilayer network </span></span><br><span class="line"><span class="comment"># method one</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Linear(num_inputs, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># other layers can be added here</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># method two</span></span><br><span class="line">net = nn.Sequential()</span><br><span class="line">net.add_module(<span class="string">'linear'</span>, nn.Linear(num_inputs, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># net.add_module ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># method three</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">net = nn.Sequential(OrderedDict([</span><br><span class="line">          (<span class="string">'linear'</span>, nn.Linear(num_inputs, <span class="number">1</span>))</span><br><span class="line">          <span class="comment"># ......</span></span><br><span class="line">        ]))</span><br><span class="line"></span><br><span class="line">print(net)</span><br><span class="line">print(net[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sequential(</span><br><span class="line">  (linear): Linear(<span class="attribute">in_features</span>=2, <span class="attribute">out_features</span>=1, <span class="attribute">bias</span>=<span class="literal">True</span>)</span><br><span class="line">)</span><br><span class="line">Linear(<span class="attribute">in_features</span>=2, <span class="attribute">out_features</span>=1, <span class="attribute">bias</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="初始化模型参数-1"><a href="#初始化模型参数-1" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> init</span><br><span class="line"></span><br><span class="line">init.normal_(net[<span class="number">0</span>].weight, mean=<span class="number">0.0</span>, std=<span class="number">0.01</span>)</span><br><span class="line">init.constant_(net[<span class="number">0</span>].bias, val=<span class="number">0.0</span>)  <span class="comment"># or you can use `net[0].bias.data.fill_(0)` to modify it directly</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parameter containing:</span><br><span class="line">tensor([0.], <span class="attribute">requires_grad</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> net.parameters():</span><br><span class="line">    print(param)</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parameter containing:</span><br><span class="line">tensor([[-0.0004, -0.0142]], <span class="attribute">requires_grad</span>=<span class="literal">True</span>)</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([0.], <span class="attribute">requires_grad</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="定义损失函数-1"><a href="#定义损失函数-1" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.MSELoss()    <span class="comment"># nn built-in squared loss function</span></span><br><span class="line">                       <span class="comment"># function prototype: `torch.nn.MSELoss(size_average=None, reduce=None, reduction='mean')`</span></span><br></pre></td></tr></table></figure><h3 id="定义优化函数-1"><a href="#定义优化函数-1" class="headerlink" title="定义优化函数"></a>定义优化函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.03</span>)   <span class="comment"># built-in random gradient descent function</span></span><br><span class="line">print(optimizer)  <span class="comment"># function prototype: `torch.optim.SGD(params, lr=, momentum=0, dampening=0, weight_decay=0, nesterov=False)`</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">SGD</span> <span class="string">(</span></span><br><span class="line"><span class="string">Parameter</span> <span class="string">Group</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">dampening:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">lr:</span> <span class="number">0.03</span></span><br><span class="line">    <span class="attr">momentum:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">nesterov:</span> <span class="literal">False</span></span><br><span class="line">    <span class="attr">weight_decay:</span> <span class="number">0</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, num_epochs + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        output = net(X)</span><br><span class="line">        l = loss(output, y.view(<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">        optimizer.zero_grad() <span class="comment"># reset gradient, equal to net.zero_grad()</span></span><br><span class="line">        l.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    print(<span class="string">'epoch %d, loss: %f'</span> % (epoch, l.item()))</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">epoch</span> <span class="number">1</span><span class="string">,</span> <span class="attr">loss:</span> <span class="number">0.000307</span></span><br><span class="line"><span class="string">epoch</span> <span class="number">2</span><span class="string">,</span> <span class="attr">loss:</span> <span class="number">0.000117</span></span><br><span class="line"><span class="string">epoch</span> <span class="number">3</span><span class="string">,</span> <span class="attr">loss:</span> <span class="number">0.000090</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># result comparision</span></span><br><span class="line">dense = net[<span class="number">0</span>]</span><br><span class="line">print(true_w, dense.weight.data)</span><br><span class="line">print(true_b, dense.bias.data)</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">-3.4</span>] tensor([[ <span class="number">2.0005</span>, <span class="number">-3.3996</span>]])</span><br><span class="line"><span class="number">4.2</span> tensor([<span class="number">4.2005</span>])</span><br></pre></td></tr></table></figure><h2 id="两种实现方式的比较"><a href="#两种实现方式的比较" class="headerlink" title="两种实现方式的比较"></a>两种实现方式的比较</h2><ol><li><p>从零开始的实现（推荐用来学习）</p><p>能够更好的理解模型和神经网络底层的原理</p></li><li><p>使用pytorch的简洁实现</p><p>能够更加快速地完成模型的设计与实现</p></li></ol><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="动手学DL (pytorch) 笔记" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%89%8B%E5%AD%A6DL-pytorch-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="jupyter notebook" scheme="http://yoursite.com/tags/jupyter-notebook/"/>
    
      <category term="线性模型" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="矢量计算" scheme="http://yoursite.com/tags/%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Hello-World</title>
    <link href="http://yoursite.com/2020/02/13/Hello-World/"/>
    <id>http://yoursite.com/2020/02/13/Hello-World/</id>
    <published>2020-02-12T17:47:20.732Z</published>
    <updated>2020-02-15T08:46:52.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Mon May 11 2020 14:18:23 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
